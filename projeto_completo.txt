
============================================================
CAMINHO: HELP.md
============================================================
# Getting Started

### Reference Documentation
For further reference, please consider the following sections:

* [Official Apache Maven documentation](https://maven.apache.org/guides/index.html)
* [Spring Boot Maven Plugin Reference Guide](https://docs.spring.io/spring-boot/3.5.6/maven-plugin)
* [Create an OCI image](https://docs.spring.io/spring-boot/3.5.6/maven-plugin/build-image.html)
* [Spring Data MongoDB](https://docs.spring.io/spring-boot/3.5.6/reference/data/nosql.html#data.nosql.mongodb)
* [Spring Web](https://docs.spring.io/spring-boot/3.5.6/reference/web/servlet.html)
* [Spring Security](https://docs.spring.io/spring-boot/3.5.6/reference/web/spring-security.html)
* [Spring Boot DevTools](https://docs.spring.io/spring-boot/3.5.6/reference/using/devtools.html)
* [Thymeleaf](https://docs.spring.io/spring-boot/3.5.6/reference/web/servlet.html#web.servlet.spring-mvc.template-engines)
* [Spring Session for Spring Data MongoDB](https://docs.spring.io/spring-session/reference/)

### Guides
The following guides illustrate how to use some features concretely:

* [Accessing Data with MongoDB](https://spring.io/guides/gs/accessing-data-mongodb/)
* [Building a RESTful Web Service](https://spring.io/guides/gs/rest-service/)
* [Serving Web Content with Spring MVC](https://spring.io/guides/gs/serving-web-content/)
* [Building REST services with Spring](https://spring.io/guides/tutorials/rest/)
* [Securing a Web Application](https://spring.io/guides/gs/securing-web/)
* [Spring Boot and OAuth2](https://spring.io/guides/tutorials/spring-boot-oauth2/)
* [Authenticating a User with LDAP](https://spring.io/guides/gs/authenticating-ldap/)
* [Handling Form Submission](https://spring.io/guides/gs/handling-form-submission/)

### Maven Parent overrides

Due to Maven's design, elements are inherited from the parent POM to the project POM.
While most of the inheritance is fine, it also inherits unwanted elements like `<license>` and `<developers>` from the parent.
To prevent this, the project POM contains empty overrides for these elements.
If you manually switch to a different parent and actually want the inheritance, you need to remove those overrides.



============================================================
CAMINHO: pom.xml
============================================================
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.5.6</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>br.com</groupId>
	<artifactId>lunix</artifactId>
	<version>0.0.1-SNAPSHOT</version>
	<name>lunix</name>
	<description>Projeto feito com o intuito de disponibilizar uma fonte confiável de informações para jogos indie</description>
	<url/>
	<licenses>
		<license/>
	</licenses>
	<developers>
		<developer/>
	</developers>
	<scm>
		<connection/>
		<developerConnection/>
		<tag/>
		<url/>
	</scm>
	<properties>
		<java.version>17</java.version>
		<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
		<project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-mongodb</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.session</groupId>
			<artifactId>spring-session-data-mongodb</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-crypto</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-devtools</artifactId>
			<scope>runtime</scope>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<version>1.18.38</version>
			<scope>provided</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>io.mongock</groupId>
			<artifactId>mongock-springboot</artifactId>
			<version>5.4.1</version> </dependency>
		<dependency>
			<groupId>io.mongock</groupId>
			<artifactId>mongodb-springdata-v4-driver</artifactId>
			<version>5.4.1</version>
		</dependency>

		<dependency>
			<groupId>org.testcontainers</groupId>
			<artifactId>junit-jupiter</artifactId>
			<scope>test</scope>
		</dependency>

		<dependency>
			<groupId>de.flapdoodle.embed</groupId>
			<artifactId>de.flapdoodle.embed.mongo</artifactId>
			<version>4.16.1</version> <scope>test</scope>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-amqp</artifactId>
		</dependency>
		<dependency>
			<groupId>com.rabbitmq</groupId>
			<artifactId>amqp-client</artifactId>
			<version>5.21.0</version>
		</dependency>
		<dependency>
			<groupId>com.auth0</groupId>
			<artifactId>java-jwt</artifactId>
			<version>4.4.0</version>
		</dependency>

		<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
			<version>2.8.5</version>
		</dependency>

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.apache.maven.plugins</groupId>
				<artifactId>maven-compiler-plugin</artifactId>
				<version>3.11.0</version>
				<configuration>
					<source>21</source>
					<target>21</target>
					<annotationProcessorPaths>
						<path>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
							<version>1.18.38</version>
						</path>
					</annotationProcessorPaths>
				</configuration>
			</plugin>

			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<layers>
						<enabled>true</enabled>
					</layers>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>


============================================================
CAMINHO: src\main\java\br\com\lunix\LunixApplication.java
============================================================
package br.com.lunix;

import io.mongock.runner.springboot.EnableMongock;
import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.info.Info;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.data.web.config.EnableSpringDataWebSupport;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableSpringDataWebSupport(pageSerializationMode = EnableSpringDataWebSupport.PageSerializationMode.VIA_DTO)
@EnableCaching
@EnableAsync
@EnableMongock
@EnableScheduling
@OpenAPIDefinition(info = @Info(title = "Lunix API", version = "1.0", description = "API para gestão de jogos indie e avaliações"))
@SecurityScheme(
		name = "bearerAuth",
		type = SecuritySchemeType.HTTP,
		scheme = "bearer",
		bearerFormat = "JWT"
)
public class LunixApplication {

	public static void main(String[] args) {
		SpringApplication.run(LunixApplication.class, args);
	}

}


============================================================
CAMINHO: src\main\java\br\com\lunix\annotation\engine\PasswordsMatchValidator.java
============================================================
package br.com.lunix.annotation.engine;

import br.com.lunix.annotation.interfaces.PasswordsMatch;
import br.com.lunix.dto.usuario.UsuarioRegistroDto;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

/*
    Classe responsável por comparar os campos de senha e
    confirmacaoSenha tem valores iguais.

    Implementa a interface **ConstraintValidator** para criar
    o método de validação utilizando o @PasswordsMatch.
*/
public class PasswordsMatchValidator implements ConstraintValidator<PasswordsMatch, UsuarioRegistroDto> {

    /*
        Método responsável por comparar os campos especificados
        e garantir que eles coincidem.

        @param dto - usuário que está sendo cadastrado
        @param context - Contexto do referente a comparação
    */
    @Override
    public boolean isValid(UsuarioRegistroDto dto, ConstraintValidatorContext context) {
        /*
            Garante que os campos não estejam vazios e
            depois os compara para garantir igualdade.
        */

        if (dto.senha() == null || dto.confirmacaoSenha() == null) {
            return true;
        }

        // A lógica principal: compara os dois campos.
        return dto.senha().equals(dto.confirmacaoSenha());
    }
}

============================================================
CAMINHO: src\main\java\br\com\lunix\annotation\engine\PastOrPresentDateValidator.java
============================================================
package br.com.lunix.annotation.engine;

import br.com.lunix.annotation.interfaces.PastOrPresentDate;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;

import java.time.LocalDate;

/*
    Classe responsável por realizar a validação de datas
    garantindo que uma data futura não está sendo inserida.

    Implementa a interface **ConstraintValidator** para criar
    o método de validação utilizando o @PastOrPresentDate.
*/
public class PastOrPresentDateValidator implements ConstraintValidator<PastOrPresentDate, LocalDate> {

    /*
        Método responsável por validar a data garantindo que
        ela não seja posterior a atual.

        @param date - Data que será validada

        return: Retorna um boolean indicando se a data passou na validação ou não
    */
    @Override
    public boolean isValid(LocalDate date, ConstraintValidatorContext context) {
        // Se a data for fazia automaticamente é invalidada
        if (date == null) {
            return true;
        }

        // Se a data for posterior a atual ela é invalidada
        return !date.isAfter(LocalDate.now());
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\annotation\engine\UniqueEmailValidator.java
============================================================
package br.com.lunix.annotation.engine;

import br.com.lunix.annotation.interfaces.UniqueEmail;
import br.com.lunix.repository.UsuarioRepository;
import jakarta.validation.ConstraintValidator;
import jakarta.validation.ConstraintValidatorContext;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;


/*
    Componente resposável por garantir que o email inserido
    seja único.
*/
@Component
public class UniqueEmailValidator implements ConstraintValidator<UniqueEmail, String> {

    // Utiliza o repositório de Usuario para buscar o usuário pelo email
    @Autowired
    private UsuarioRepository usuarioRepository;

    /*
        Realiza a validação do email

        @param email - Email a ser validado

        return: boolean indicando se o email é válido ou não
    */
    @Override
    public boolean isValid(String email, ConstraintValidatorContext context) {
        // Se o email estiver vazio automaticamente falha na validação
        if (email == null || email.trim().isEmpty()) {
            return true;
        }

        // Se ele encontrar um email no banco igual ao inserido falha na validação
        return !usuarioRepository.findByEmail(email).isPresent();
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\annotation\interfaces\PasswordsMatch.java
============================================================
package br.com.lunix.annotation.interfaces;

import br.com.lunix.annotation.engine.PasswordsMatchValidator;
import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/*
    Anotação criada para verificar se os campos de 'senha' e 'confirme a senha'
    tem exatamente o mesmo valor.
*/
@Constraint(validatedBy = PasswordsMatchValidator.class)
@Target({ ElementType.TYPE })
@Retention(RetentionPolicy.RUNTIME)
public @interface PasswordsMatch {

    String message() default "As senhas não coincidem.";

    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}


============================================================
CAMINHO: src\main\java\br\com\lunix\annotation\interfaces\PastOrPresentDate.java
============================================================
package br.com.lunix.annotation.interfaces;

import br.com.lunix.annotation.engine.PastOrPresentDateValidator;
import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/*
    Anotação utilizada para definir que uma data de lançamento de jogo
    não pode ser em uma data futura.
*/
@Constraint(validatedBy = PastOrPresentDateValidator.class)
@Target({ ElementType.FIELD })
@Retention(RetentionPolicy.RUNTIME)
public @interface PastOrPresentDate {
    String message() default "A data não pode ser no futuro.";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}


============================================================
CAMINHO: src\main\java\br\com\lunix\annotation\interfaces\UniqueEmail.java
============================================================
package br.com.lunix.annotation.interfaces;

import br.com.lunix.annotation.engine.UniqueEmailValidator;
import jakarta.validation.Constraint;
import jakarta.validation.Payload;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/*
    Anotação para garantir que o email inserido
    seja único.
*/
@Constraint(validatedBy = UniqueEmailValidator.class)
@Target({ ElementType.FIELD })
@Retention(RetentionPolicy.RUNTIME)
public @interface UniqueEmail {
    String message() default "Este e-mail já está em uso.";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}


============================================================
CAMINHO: src\main\java\br\com\lunix\config\migrations\V1_001__CreateInitialIndexes.java
============================================================
package br.com.lunix.config.migrations;

import io.mongock.api.annotations.ChangeUnit;
import io.mongock.api.annotations.Execution;
import io.mongock.api.annotations.RollbackExecution;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.index.Index;

/*
    Classe de migração para criar Indices para deixar a pesquisa
    mais perfomática
*/
@ChangeUnit(id = "create-initial-indexes", order = "001", author = "lunix-dev")
public class V1_001__CreateInitialIndexes {

    /*
        Método que cria Indice com valor único para o campo de email
        no documento

        @param template - Template para acesso a métodos do mongo para configurações como
        criação de indices e de documentos
    */
    @Execution
    public void createUserEmailIndex(MongoTemplate template) {
        System.out.println("MONGOCK[001]: Criando indíce único para o email de usuário...");
        template.indexOps("usuarios").createIndex(new Index().on("email", Sort.Direction.ASC).unique());
    }

    /*
        Método de rollback para retirar os indíces em
        caso de algum problema
    */
    @RollbackExecution
    public void rollback(MongoTemplate template) {
        template.indexOps("usuarios").dropIndex("email_1");
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\config\migrations\V1_002__SeedUsersAndCompanies.java
============================================================
package br.com.lunix.config.migrations;

import br.com.lunix.model.entities.Empresa;
import br.com.lunix.model.entities.Usuario;
import br.com.lunix.model.enums.Role;
import io.mongock.api.annotations.ChangeUnit;
import io.mongock.api.annotations.Execution;
import io.mongock.api.annotations.RollbackExecution;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.security.crypto.password.PasswordEncoder;

import java.util.Set;

// Classe de migração para a inserção inicial de usuários e empresas
@ChangeUnit(id = "seed-users-and-companies", order = "002", author = "lunix-dev")
public class V1_002__SeedUsersAndCompanies {

    public static Usuario admin, devAutonomo, user;
    public static Empresa empresa;

    /*
        Método de execução de migração que insere usuários
        e empresas para dados iniciais da aplicação.

        @param template - template do mongo para configurações como
        deletar coleções e inserir os dados.

        @param encoder - encoder para decodificar a senha.
    */
    @Execution
    public void seedInitialUsersAndCompanies(MongoTemplate template, PasswordEncoder encoder) {
        /*
            O método primeiramente deleta as coleções para deletar
            os dados utilizados nos testes de integração e depois
            cria 1 usuário para cada tipo de perfil e os insere no banco.
        */
        System.out.println("MONGOCK[002]: Inserindo usuários e empresas iniciais...");
        template.dropCollection("usuarios");
        template.dropCollection("empresas");

        admin = new Usuario();
        admin.setNome("Admin Lunix");
        admin.setEmail("admin@lunix.com");
        admin.setSenha(encoder.encode("admin123"));
        admin.setRoles(Set.of(Role.ROLE_ADMIN, Role.ROLE_USER));
        template.save(admin);

        devAutonomo = new Usuario();
        devAutonomo.setNome("Toby Fox");
        devAutonomo.setEmail("toby@fox.com");
        devAutonomo.setSenha(encoder.encode("dev123"));
        devAutonomo.setRoles(Set.of(Role.ROLE_DEV));
        template.save(devAutonomo);

        user = new Usuario();
        user.setNome("User");
        user.setEmail("user@gmail.com");
        user.setSenha(encoder.encode("user123"));
        user.setRoles(Set.of(Role.ROLE_USER));
        template.save(user);

        empresa = new Empresa();
        empresa.setNome("Team Cherry");
        empresa.setPaisOrigem("Austrália");
        empresa.setDescricao("Team Cherry é uma pequena, independente desenvolvedora de jogos situada em Adelaide, Austrália do Sul, fundada em 2014.");
        template.save(empresa);
    }

    /*
        Método de Rollback em caso de erro que deleta as
        coleções.
    */
    @RollbackExecution
    public void rollback(MongoTemplate template) {
        template.dropCollection("empresas");
        template.dropCollection("usuarios");
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\config\migrations\V1_003__SeedGamesAndReviews.java
============================================================
package br.com.lunix.config.migrations;

import br.com.lunix.model.entities.Avaliacao;
import br.com.lunix.model.entities.Jogo;
import br.com.lunix.model.enums.ClassificacaoIndicativa;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import io.mongock.api.annotations.ChangeUnit;
import io.mongock.api.annotations.Execution;
import io.mongock.api.annotations.RollbackExecution;
import org.springframework.data.mongodb.core.MongoTemplate;

import java.time.LocalDate;
import java.util.List;

import static br.com.lunix.config.migrations.V1_002__SeedUsersAndCompanies.*;

/*
    Classe de migração para inserir dados iniciais de jogos
    e avaliações.
*/
@ChangeUnit(id = "seed-games-and-reviews", order = "003", author = "lunix-dev")
public class V1_003__SeedGamesAndReviews {

    /*
        Método de execução para inserir os dados iniciais
        de jogos e avaliações.

        @param template - template do mongo para configurações como
        deletar coleções e inserir os dados.
    */
    @Execution
    public void seedInitialGamesAndReviews(MongoTemplate template) {
        /*
            O método primeiramente deleta as coleções para
            não ficarem registrados os dados de testes
            e inserir dados 100% novos.

            Logo após insere um jogo feito por um dev autonômo
            e um feito por uma empresa e cria duas avaliações para
            o Hollow Knight.
        */
        System.out.println("MONGOCK[003]: Inserindo jogos e avaliações iniciais...");
        template.dropCollection("jogos");
        template.dropCollection("avaliacoes");

        Jogo undertale = new Jogo();
        undertale.setTitulo("Undertale");
        undertale.setDescricao("Um RPG onde ninguém precisa morrer.");
        undertale.setDevAutonomo(devAutonomo);
        undertale.setDataLancamento(LocalDate.of(2015, 9, 15));
        undertale.setClassificacao(ClassificacaoIndicativa.DOZE);
        undertale.setGeneros(List.of(Genero.RPG, Genero.AVENTURA));
        undertale.setPlataformas(List.of(Plataforma.PC, Plataforma.PLAYSTATION_4, Plataforma.NINTENDO_SWITCH));
        template.save(undertale);

        Jogo hollowKnight = new Jogo();
        hollowKnight.setTitulo("Hollow Knight");
        hollowKnight.setDescricao("Explore um vasto reino de insetos e descubra como parar a infecção");
        hollowKnight.setEmpresa(empresa);
        hollowKnight.setDataLancamento(LocalDate.of(2017, 2, 24));
        hollowKnight.setClassificacao(ClassificacaoIndicativa.DEZ);
        hollowKnight.setGeneros(List.of(Genero.METROIDVANIA, Genero.AVENTURA));
        hollowKnight.setPlataformas(List.of(Plataforma.PC, Plataforma.PLAYSTATION_4, Plataforma.XBOX_ONE, Plataforma.NINTENDO_SWITCH, Plataforma.MACOS, Plataforma.LINUX));
        template.save(hollowKnight);

        Avaliacao avaliacaoAdmin = new Avaliacao();
        avaliacaoAdmin.setUsuario(admin);
        avaliacaoAdmin.setJogo(hollowKnight);
        avaliacaoAdmin.setNota(10);
        avaliacaoAdmin.setUsuario(admin);
        avaliacaoAdmin.setComentario("Análise do Admin: Uma obra-prima do gênero metroidvania.");
        template.save(avaliacaoAdmin);

        Avaliacao avaliacaoUser = new Avaliacao();
        avaliacaoUser.setUsuario(user);
        avaliacaoUser.setJogo(hollowKnight);
        avaliacaoUser.setNota(9);
        avaliacaoUser.setUsuario(user);
        avaliacaoUser.setComentario("Muito desafiador, mas recompensador. Adorei!");
        template.save(avaliacaoUser);
    }

    /*
        Método de rollback para deletar as coleções
        em caso de algum problema na execução
    */
    @RollbackExecution
    public void rollback(MongoTemplate template) {
        template.dropCollection("avaliacoes");
        template.dropCollection("jogos");
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\config\migrations\V1_004__CreateQueryIndexes.java
============================================================
package br.com.lunix.config.migrations;

import com.mongodb.client.model.Indexes;
import io.mongock.api.annotations.ChangeUnit;
import io.mongock.api.annotations.Execution;
import io.mongock.api.annotations.RollbackExecution;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.index.Index;

/*
    Classe de migração para criar indices de query
    para maior perfomance de pesquisas.
*/
@ChangeUnit(id = "create-query-indexes", order = "004", author = "lunix-dev")
public class V1_004__CreateQueryIndexes {

    /*
        Método de execução que pega as coleções alvo
        e gera indices para cada parâmetro preciso.
    */
    @Execution
    public void createPerfomanceIndexes(MongoTemplate template) {
        System.out.println("MONGOCK[004]: Criando índices de perfomance...");

        template.getCollection("jogos").createIndex(Indexes.text("titulo"));
        template.indexOps("jogos").createIndex(new Index().on("generos", Sort.Direction.ASC));

        template.indexOps("avaliacoes").createIndex(new Index().on("jogo", Sort.Direction.ASC));
        template.indexOps("avaliacoes").createIndex(new Index().on("usuario", Sort.Direction.ASC));

        template.indexOps("empresas").createIndex(new Index().on("nome", Sort.Direction.ASC));
    }

    /*
        Método de rollback para em caso de erro na
        execução sejam deletados os indices.
    */
    @RollbackExecution
    public void rollback(MongoTemplate template) {
        template.indexOps("jogos").dropIndex("titulo_text");
        template.indexOps("avaliacoes").dropIndex("jogo_1");
        template.indexOps("avaliacoes").dropIndex("usuario_1");
        template.indexOps("jogos").dropIndex("generos_1");
        template.indexOps("empresas").dropIndex("nome_1");
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\config\migrations\V1_005__CreatePlatformIndex.java
============================================================
package br.com.lunix.config.migrations;

import io.mongock.api.annotations.ChangeUnit;
import io.mongock.api.annotations.Execution;
import io.mongock.api.annotations.RollbackExecution;
import org.springframework.data.domain.Sort;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.data.mongodb.core.index.Index;

/*
    Classe de migração responsável por criar um
    indice para o campo de plataformas criando
    pesquisas mais dinâmicas.
*/
@ChangeUnit(id = "create-platform-index", order = "005", author = "lunix-dev")
public class V1_005__CreatePlatformIndex {

    /*
        Método de execução que cria o indice
        no campo plataformas da collection de
        jogos.
    */
    @Execution
    public void createPlatformIndex(MongoTemplate template) {
        System.out.println("MONGOCK[005]: Criando um índice multichave em jogos.plataformas");
        template.indexOps("jogos")
                .createIndex(new Index().on("plataformas", Sort.Direction.ASC));
    }

    /*
        ROllback em caso de problemas deletando
        o indice criado.
    */
    @RollbackExecution
    public void rollback(MongoTemplate template) {
        template.indexOps("jogos").dropIndex("plataformas_1");
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\config\rabbit\RabbitMQConfig.java
============================================================
package br.com.lunix.config.rabbit;

import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.amqp.core.Queue;

@Configuration
public class RabbitMQConfig {

    @Value("${indiezone.rabbitmq.queue}")
    private String queueName;

    @Bean
    public Queue queue() {
        return new Queue(queueName, true);
    }

    @Bean
    public Jackson2JsonMessageConverter messageConverter() {
        return new Jackson2JsonMessageConverter();
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\config\security\SecurityConfig.java
============================================================
package br.com.lunix.config.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/*
    Classe de configuração de seguraça da aplicação.

    @method PasswordEncoder - Método responsável por criptografar as senhas dos usuários.
    @method SecurityFilterChain - Método responsável por definir as rotas públicas e privadas da aplicação.
*/
@Configuration
@EnableWebSecurity
@EnableMethodSecurity(securedEnabled = true)
public class SecurityConfig {

    /*
        Bean responsável por realizar a criptografia de senhas
        no momento do cadastro utilizando o BCryptPasswordEncoder.
    */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Autowired
    private SecurityFilter securityFilter;

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity httpSecurity) throws Exception {
        return httpSecurity
                .csrf(AbstractHttpConfigurer::disable) // Desliga CSRF (desnecessário para API REST)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorize -> authorize
                        // Rotas Públicas (Login, Registro e Swagger)
                        .requestMatchers(HttpMethod.POST, "/auth/**").permitAll() // Login e Register
                        .requestMatchers(HttpMethod.GET, "/actuator/**").permitAll() // Monitoramento
                        .requestMatchers("/v3/api-docs/**", "/swagger-ui/**", "/swagger-ui.html").permitAll()

                        .requestMatchers("/jogos/import/**").hasAnyRole("DEV", "ADMIN")
                        .requestMatchers(HttpMethod.GET, "/jogos/meus-jogos").hasAnyRole("DEV", "ADMIN")

                        // Mudamos a controller, então a rota base agora é /dashboard
                        .requestMatchers("/admin/dashboard/**").hasRole("ADMIN")

                        // Rota de sync de preços (JogoController)
                        .requestMatchers(HttpMethod.POST, "/jogos/sync-prices").hasRole("ADMIN")

                        .requestMatchers(HttpMethod.GET, "/jogos/**").permitAll()
                        .requestMatchers(HttpMethod.GET, "/empresas/**").permitAll()

                        .requestMatchers("/v3/api-docs/**", "/swagger-ui/**", "/swagger-ui.html", "/api-docs/**").permitAll() // Swagger
                        // Todo o resto exige autenticação
                        .anyRequest().authenticated()
                )
                .addFilterBefore(securityFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\config\security\SecurityFilter.java
============================================================
package br.com.lunix.config.security;

import br.com.lunix.repository.UsuarioRepository;
import br.com.lunix.services.usuario.TokenService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class SecurityFilter extends OncePerRequestFilter {

    @Autowired
    private TokenService tokenService;

    @Autowired
    private UsuarioRepository usuarioRepository;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        var token = this.recoverToken(request);

        if (token != null) {
            var login = tokenService.validateToken(token);

            if (login != null && !login.isEmpty()) {
                var user = usuarioRepository.findByEmail(login)
                        .orElseThrow(() -> new RuntimeException("Usuário não encontrado no token"));

                var authentication = new UsernamePasswordAuthenticationToken(user, null, user.getAuthorities());
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        }
        filterChain.doFilter(request, response);
    }

    private String recoverToken(HttpServletRequest request) {
        var authHeader = request.getHeader("Authorization");
        if (authHeader == null) return null;

        return authHeader.replace("Bearer ", "");
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\config\security\UserDetailsServiceImpl.java
============================================================
package br.com.lunix.config.security;

import br.com.lunix.repository.UsuarioRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

/*
    Serviço responsável por controlar o acesso dos usuários
    e controlar o login dos mesmos.

    Implementa a interface UserDetailsService para acesso a métodos
    que permitem o controle de entrada dos usuários.
*/
@Service
public class UserDetailsServiceImpl implements UserDetailsService {

    // Repositório injetado de usuário para acesso ao documento de usuários
    @Autowired
    private UsuarioRepository repository;

    /*
        Método que procura um usuário utilizando o parâmetro escolhido.

        @param email - email utilizado para buscar o usuário.

        Em caso de erro lança uma exceção de usuário não encontrado.

        return: Retorna o usuário com email inserido.
    */
    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        return repository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("Usuário não encontrado com o email: " + email));
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\consumers\JogoPrecoConsumer.java
============================================================
package br.com.lunix.consumers;

import br.com.lunix.services.jogo.JogoPrecoService;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class JogoPrecoConsumer {

    private static final Logger log = LoggerFactory.getLogger(JogoPrecoConsumer.class);

    private final JogoPrecoService precoService;

    /*
        Método que ouve a fila de atualização de preços

        @param jogoId - ID do jogo a ser atualizado
    */
    @RabbitListener(queues = "${indiezone.rabbitmq.queue}")
    public void consumirMensagem(String jogoId) {
        log.info("Mensagem recebida da fila. Iniciando atualização para Jogo ID: {}", jogoId);

        try {
            // A regra de negócio é delegada para a Service
            boolean atualizou = precoService.processarAtualizacaoLogica(jogoId);

            if (atualizou) {
                // Rate limiting: Pausa estratégica para respeitar a API do ITAD
                Thread.sleep(2000);
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.error("Consumer interrompido inesperadamente", e);
        } catch (Exception e) {
            // Loga o erro mas não derruba o listener.
            log.error("Erro ao processar atualização de preço para o ID: {}", jogoId, e);
        }
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\controller\AuthController.java
============================================================
package br.com.lunix.controller;

import br.com.lunix.dto.error.StandardError;
import br.com.lunix.dto.usuario.TokenResponseDto;
import br.com.lunix.dto.usuario.UsuarioLoginDto;
import br.com.lunix.dto.usuario.UsuarioProfileDto;
import br.com.lunix.dto.usuario.UsuarioRegistroDto;
import br.com.lunix.services.usuario.UsuarioService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;

@RestController
@RequestMapping("/auth")
@Tag(name = "Autenticação", description = "Endpoints públicos responsáveis pelo registro de novos usuários e login.")
@RequiredArgsConstructor
public class AuthController {

    private final UsuarioService service;

    @PostMapping("/login")
    @Operation(summary = "Realizar login", description = "Autentica um usuário utilizando e-mail e senha. Retorna um Token JWT se as credenciais forem válidas")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Login realizado com sucesso",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = TokenResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Dados de entrada inválidos", content = @Content),
            @ApiResponse(responseCode = "401", description = "Credenciais inválidas",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class))),
            @ApiResponse(responseCode = "403", description = "Conta desativada",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<TokenResponseDto> login(@RequestBody @Valid UsuarioLoginDto dto) {
        TokenResponseDto token = service.login(dto);

        return ResponseEntity.ok(token);
    }

    @PostMapping("/register")
    @Operation(summary = "Registrar um novo usuário", description = "Cria uma nova conta de usuário com perfil padrão. Verifica se o e-mail já existe no banco antes de salvar.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Usuário criado com sucesso",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UsuarioProfileDto.class))),
            @ApiResponse(responseCode = "422", description = "Erro de validação",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class))),
            @ApiResponse(responseCode = "400", description = "Violação de regra de negócio",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<UsuarioProfileDto> registrar(@RequestBody @Valid UsuarioRegistroDto dto) {
        UsuarioProfileDto novoUsuario = service.registrar(dto);

        URI uri = ServletUriComponentsBuilder.fromCurrentContextPath()
                .path("/usuarios/{id}")
                .buildAndExpand(novoUsuario.id())
                .toUri();

        return ResponseEntity.created(uri).body(novoUsuario);
    }

}


============================================================
CAMINHO: src\main\java\br\com\lunix\controller\DashboardController.java
============================================================
package br.com.lunix.controller;

import br.com.lunix.dto.dashboard.DashboardJogoDto;
import br.com.lunix.dto.error.StandardError;
import br.com.lunix.services.dashboard.DashboardService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/admin/dashboard")
@Tag(name = "Dashboard", description = "Dados analíticos e estatísticos para administração.")
@SecurityRequirement(name = "bearerAuth")
@RequiredArgsConstructor
public class DashboardController {

    private final DashboardService dashboardService;

    @GetMapping("/jogos")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Métricas de Jogos", description = "Retorna contagem total, jogos sem preço e distribuição por gênero.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Dados retornados com sucesso",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = DashboardJogoDto.class))),
            @ApiResponse(responseCode = "403", description = "Acesso negado (Requer ADMIN)",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<DashboardJogoDto> getDadosDashboard() {
        return ResponseEntity.ok(dashboardService.gerarDadosDashboard());
    }
}

============================================================
CAMINHO: src\main\java\br\com\lunix\controller\EmpresaController.java
============================================================
package br.com.lunix.controller;

import br.com.lunix.dto.empresa.EmpresaDetalhesDto;
import br.com.lunix.dto.empresa.EmpresaRequestDto;
import br.com.lunix.dto.empresa.EmpresaResponseDto;
import br.com.lunix.dto.empresa.EmpresaUpdateDto;
import br.com.lunix.dto.error.StandardError;
import br.com.lunix.services.empresa.EmpresaService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;

@RestController
@RequestMapping("/empresas")
@Tag(name = "Empresas", description = "Endpoints para gestão de estúdios e empresas desenvolvedoras.")
@SecurityRequirement(name = "bearerAuth")
@RequiredArgsConstructor
public class EmpresaController {

    private final EmpresaService service;

    @GetMapping
    @Operation(summary = "Listar Todas", description = "Retorna uma lista paginada de todas as empresas cadastradas.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Empresas encontradas",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = EmpresaResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Nenhuma empresa encontrada",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Page<EmpresaResponseDto>> listarTodas(
            @Parameter(description = "Número da página", example = "0") @RequestParam(defaultValue = "0") int page,
            @Parameter(description = "Itens por página", example = "10") @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(service.findAll(page, size));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Detalhes da Empresa", description = "Retorna dados da empresa e a lista de jogos desenvolvidos por ela.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Empresa encontrada",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = EmpresaDetalhesDto.class))),
            @ApiResponse(responseCode = "404", description = "Empresa não encontrada",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<EmpresaDetalhesDto> buscarPorId(
            @Parameter(description = "ID da empresa", example = "650c...") @PathVariable String id
    ) {
        return ResponseEntity.ok(service.findById(id));
    }

    @GetMapping("/pais")
    @Operation(summary = "Filtrar por País", description = "Busca empresas filtrando pelo país de origem.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Empresa encontrada",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = EmpresaResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Nenhuma empresa encontrada",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Page<EmpresaResponseDto>> buscarPorPais(
            @Parameter(description = "Nome do país", example = "Brasil") @RequestParam String nome,
            @Parameter(description = "Número da página", example = "0") @RequestParam(defaultValue = "0") int page,
            @Parameter(description = "Itens por página", example = "10") @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(service.findByPais(nome, page, size));
    }

    @GetMapping("/nome")
    @Operation(summary = "Filtrar por Nome", description = "Busca empresas filtrando pelo nome.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Empresa encontrada",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = EmpresaResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Nenhuma empresa encontrada",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Page<EmpresaResponseDto>> buscarPorNome(
            @Parameter(description = "Nome da empresa", example = "Team Cherry") @RequestParam String nome,
            @Parameter(description = "Número da página", example = "0") @RequestParam(defaultValue = "0") int page,
            @Parameter(description = "Itens por página", example = "10") @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(service.findByNome(nome, page, size));
    }

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Cadastrar Empresa (Admin)", description = "Registra um novo estúdio/empresa na plataforma.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Empresa criada com sucesso",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = EmpresaResponseDto.class))),
            @ApiResponse(responseCode = "400", description = "Erro de validação ou nome duplicado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class))),
            @ApiResponse(responseCode = "403", description = "Acesso negado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<EmpresaResponseDto> cadastrar(@RequestBody @Valid EmpresaRequestDto dto) {
        EmpresaResponseDto novaEmpresa = service.create(dto);
        URI uri = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
                .buildAndExpand(novaEmpresa.id()).toUri();
        return ResponseEntity.created(uri).body(novaEmpresa);
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Atualizar Empresa (Admin)", description = "Atualiza dados cadastrais da empresa.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Atualizado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Empresa não encontrada"),
            @ApiResponse(responseCode = "403", description = "Acesso negado")
    })
    public ResponseEntity<EmpresaResponseDto> atualizar(
            @Parameter(description = "ID da empresa", example = "650c...") @PathVariable String id,
            @RequestBody @Valid EmpresaUpdateDto dto
    ) {
        return ResponseEntity.ok(service.update(id, dto));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Deletar Empresa (Admin)", description = "Remove o registro de uma empresa do sistema.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Deletado com sucesso"),
            @ApiResponse(responseCode = "404", description = "Empresa não encontrada"),
            @ApiResponse(responseCode = "403", description = "Acesso negado")
    })
    public ResponseEntity<Void> deletar(
            @Parameter(description = "ID da empresa", example = "650c...") @PathVariable String id
    ) {
        service.delete(id);
        return ResponseEntity.noContent().build();
    }
}

============================================================
CAMINHO: src\main\java\br\com\lunix\controller\JogoController.java
============================================================
package br.com.lunix.controller;

import br.com.lunix.dto.error.StandardError;
import br.com.lunix.dto.jogos.*;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import br.com.lunix.services.jogo.JogoImportService;
import br.com.lunix.services.jogo.JogoPrecoService;
import br.com.lunix.services.jogo.JogoService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.support.ServletUriComponentsBuilder;

import java.net.URI;
import java.util.List;

@RestController
@RequestMapping("/jogos")
@Tag(name = "Jogos", description = "Endpoints para gestão, busca e vitrine de jogos indie.")
@SecurityRequirement(name = "bearerAuth")
@RequiredArgsConstructor
public class JogoController {

    private final JogoService jogoService;

    private final JogoPrecoService precoService;

    @GetMapping("/{id}")
    @Operation(summary = "Detalhes do Jogo", description = "Retorna dados completos, incluindo avaliações separadas por perfil.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Jogo encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = JogoDetalhesDto.class))),
            @ApiResponse(responseCode = "404", description = "Jogo não encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<JogoDetalhesDto> buscarPorId(@PathVariable String id) {
        return ResponseEntity.ok(jogoService.buscarDetalhesPorId(id));
    }

    @GetMapping
    @Operation(summary = "Listar Todos", description = "Lista paginada ordenada por data de lançamento.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Jogos encontrados",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = JogoResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Nenhum jogo encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Page<JogoResponseDto>> listarTodos(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(jogoService.listarTodos(page, size));
    }

    @GetMapping("/search")
    @Operation(summary = "Buscar por Título", description = "Pesquisa jogos pelo nome (busca parcial case-insensitive).")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Jogo encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = JogoResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Jogo não encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Page<JogoResponseDto>> buscarPorTitulo(
            @RequestParam String termo,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(jogoService.buscarPorTitulo(termo, page, size));
    }

    @GetMapping("/genero/{genero}")
    @Operation(summary = "Filtrar por Gênero")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Jogo encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = JogoResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Jogo não encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Page<JogoResponseDto>> buscarPorGenero(
            @PathVariable Genero genero,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(jogoService.buscarPorGenero(genero, page, size));
    }

    @GetMapping("/plataforma/{plataforma}")
    @Operation(summary = "Filtrar por Plataforma")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Jogo encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = JogoResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Jogo não encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Page<JogoResponseDto>> buscarPorPlataforma(
            @PathVariable Plataforma plataforma,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(jogoService.buscarPorPlataforma(plataforma, page, size));
    }

    @GetMapping("/empresa/{id}")
    @Operation(summary = "Filtrar por Empresa")

    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Sucesso", content = @Content(schema = @Schema(implementation = JogoResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Empresa não encontrada", content = @Content(schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Page<JogoResponseDto>> buscarPorEmpresa(
            @PathVariable String id,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(jogoService.buscarPorEmpresa(id, page, size));
    }

    @GetMapping("/dev/{id}")
    @Operation(summary = "Filtrar por Desenvolvedor")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Sucesso", content = @Content(schema = @Schema(implementation = JogoResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Desenvolvedor não encontrado", content = @Content(schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Page<JogoResponseDto>> buscarPorDev(
            @PathVariable String id,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(jogoService.buscarPorDev(id, page, size));
    }

    @GetMapping("/top-avaliados")
    @Operation(summary = "Top 10 Melhores")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Sucesso", content = @Content(schema = @Schema(implementation = JogoResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Jogos não encontrados", content = @Content(schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<List<JogoResponseDto>> topAvaliados() {
        return ResponseEntity.ok(jogoService.buscarTop10MelhoresAvaliados());
    }

    @GetMapping("/lancamentos")
    @Operation(summary = "Lançamentos Recentes")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Sucesso", content = @Content(schema = @Schema(implementation = JogoResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Jogos não encontrados", content = @Content(schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<List<JogoResponseDto>> topLancamentos() {
        return ResponseEntity.ok(jogoService.buscarTop10Lancamentos());
    }

    @PostMapping
    @Operation(summary = "Cadastrar Jogo", description = "Cadastra um novo jogo. Admins podem definir o dono.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Criado com sucesso"),
            @ApiResponse(responseCode = "400", description = "Erro de validação", content = @Content(schema = @Schema(implementation = StandardError.class))),
            @ApiResponse(responseCode = "403", description = "Acesso negado", content = @Content(schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<JogoResponseDto> cadastrar(@RequestBody @Valid JogoAdminRequestDto dto) {
        JogoResponseDto novoJogo = jogoService.cadastrar(dto);
        URI uri = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}")
                .buildAndExpand(novoJogo.id()).toUri();
        return ResponseEntity.created(uri).body(novoJogo);
    }

    @GetMapping("/meus-jogos")
    @Operation(summary = "Meus Jogos (Área do Dev)", description = "Lista jogos do usuário logado.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Jogos encontrados", content = @Content(schema = @Schema(implementation = JogoResponseDto.class))),
            @ApiResponse(responseCode = "404", description = "Jogos não encontrados", content = @Content(schema = @Schema(implementation = StandardError.class))),
            @ApiResponse(responseCode = "403", description = "Acesso negado (Requer acesso de DEV)")
    })
    public ResponseEntity<Page<JogoResponseDto>> listarMeusJogos(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(jogoService.listarMeusJogos(page, size));
    }

    @PutMapping("/{id}")
    @Operation(summary = "Atualizar Jogo", description = "Requer permissão de Dono ou Admin.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Atualizado com sucesso"),
            @ApiResponse(responseCode = "403", description = "Sem permissão", content = @Content(schema = @Schema(implementation = StandardError.class))),
            @ApiResponse(responseCode = "404", description = "Não encontrado", content = @Content(schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<JogoResponseDto> atualizar(
            @PathVariable String id,
            @RequestBody @Valid JogoUpdateDto dto
    ) {
        return ResponseEntity.ok(jogoService.atualizar(id, dto));
    }

    @PatchMapping("/{id}/generos")
    @Operation(summary = "Atualizar Gêneros")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Atualizado com sucesso"),
            @ApiResponse(responseCode = "403", description = "Sem permissão", content = @Content(schema = @Schema(implementation = StandardError.class))),
            @ApiResponse(responseCode = "404", description = "Não encontrado", content = @Content(schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Void> atualizarGeneros(
            @PathVariable String id,
            @RequestBody @Valid JogoGenresPatchDto dto
    ) {
        jogoService.patchGeneros(id, dto);
        return ResponseEntity.noContent().build();
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Deletar Jogo")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Deletado com sucesso"),
            @ApiResponse(responseCode = "403", description = "Sem permissão", content = @Content(schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Void> deletar(@PathVariable String id) {
        jogoService.deletar(id);
        return ResponseEntity.noContent().build();
    }

    @PostMapping("/sync-prices")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Sincronização Global de Preços (Admin)", description = "Dispara atualização de todos os jogos via RabbitMQ.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "202", description = "Processamento iniciado"),
            @ApiResponse(responseCode = "403", description = "Acesso negado")
    })
    public ResponseEntity<Void> syncPrices() {
        precoService.solicitarAtualizacaoGlobalAdmin();
        return ResponseEntity.accepted().build();
    }
}

============================================================
CAMINHO: src\main\java\br\com\lunix\controller\JogoImportController.java
============================================================
package br.com.lunix.controller;

import br.com.lunix.dto.error.StandardError;
import br.com.lunix.dto.jogos.JogoMapeadoDto;
import br.com.lunix.services.jogo.JogoImportService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/jogos/import")
@SecurityRequirement(name = "bearerAuth")// Rota base para importações
@Tag(name = "Integrações / Importação", description = "Ferramentas para buscar metadados de APIs externas.")
@RequiredArgsConstructor
public class JogoImportController {

    private final JogoImportService importService;

    @GetMapping("/rawg")
    @Operation(summary = "Importar do RAWG", description = "Busca metadados na API da RAWG pelo título para preenchimento automático.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Dados encontrados e mapeados",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = JogoMapeadoDto.class))),
            @ApiResponse(responseCode = "404", description = "Jogo não encontrado na base externa",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<JogoMapeadoDto> importarDadosRawg(
            @Parameter(description = "Título do jogo", example = "Hollow Knight") @RequestParam String titulo
    ) {
        return ResponseEntity.ok(importService.importarDadosRawg(titulo));
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\controller\UsuarioController.java
============================================================
package br.com.lunix.controller;

import br.com.lunix.dto.error.StandardError;
import br.com.lunix.dto.usuario.UsuarioAdminListDto;
import br.com.lunix.dto.usuario.UsuarioProfileDto;
import br.com.lunix.dto.usuario.UsuarioRolePatchDto;
import br.com.lunix.dto.usuario.UsuarioUpdateDto;
import br.com.lunix.model.entities.Usuario;
import br.com.lunix.services.usuario.UsuarioService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/usuarios")
@Tag(name = "Usuários", description = "Endpoints para gestão de perfil e administração de usuários.")
@SecurityRequirement(name = "bearerAuth")
@RequiredArgsConstructor
public class UsuarioController {

    private final UsuarioService service;

    @GetMapping
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Listar todos (Admin)", description = "Retorna uma lista paginada de todos os usuários cadastrados. Exclusivo para Administradores.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Lista retornada com sucesso"),
            @ApiResponse(responseCode = "403", description = "Acesso negado (Usuário não é ADMIN)",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Page<UsuarioAdminListDto>> listarTodos(
            @Parameter(description = "Número da página", example = "0") @RequestParam(defaultValue = "0") int page,
            @Parameter(description = "Quantidade de itens por página", example = "10") @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(service.listarTodos(page, size));
    }

    @GetMapping("/search")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Buscar por nome (Admin)", description = "Realiza uma busca parcial pelo nome do usuário. Útil para filtros em Dashboards.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Busca realizada com sucesso"),
            @ApiResponse(responseCode = "403", description = "Acesso negado (Usuário não é ADMIN)",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Page<UsuarioAdminListDto>> buscarPorNome(
            @Parameter(description = "Trecho do nome a ser buscado", example = "Jean") @RequestParam String nome,
            @Parameter(description = "Número da página", example = "0") @RequestParam(defaultValue = "0") int page,
            @Parameter(description = "Itens por página", example = "10") @RequestParam(defaultValue = "10") int size
    ) {
        return ResponseEntity.ok(service.buscarPorNome(nome, page, size));
    }

    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Atualizar usuário (Admin)", description = "Atualiza dados cadastrais, status (ativo/inativo) e vínculo com empresa.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Usuário atualizado com sucesso",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UsuarioAdminListDto.class))),
            @ApiResponse(responseCode = "404", description = "Usuário ou Empresa não encontrados",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class))),
            @ApiResponse(responseCode = "400", description = "Erro de validação nos campos enviados",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class))),
            @ApiResponse(responseCode = "403", description = "Acesso negado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<UsuarioAdminListDto> atualizar(
            @Parameter(description = "ID do usuário a ser atualizado", example = "650c...") @PathVariable String id,
            @RequestBody @Valid UsuarioUpdateDto dto
    ) {
        return ResponseEntity.ok(service.atualizar(id, dto));
    }

    @PatchMapping("/{id}/roles")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Alterar permissões (Admin)", description = "Promove ou rebaixa usuários alterando suas Roles (Ex: USER -> DEV).")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Permissões atualizadas com sucesso",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UsuarioAdminListDto.class))),
            @ApiResponse(responseCode = "404", description = "Usuário não encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class))),
            @ApiResponse(responseCode = "403", description = "Acesso negado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<UsuarioAdminListDto> atualizarRoles(
            @Parameter(description = "ID do usuário", example = "650c...") @PathVariable String id,
            @RequestBody @Valid UsuarioRolePatchDto dto
    ) {
        return ResponseEntity.ok(service.atualizarRoles(id, dto));
    }

    @DeleteMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Desativar conta (Admin)", description = "Realiza a exclusão lógica (Soft Delete), definindo o status do usuário como inativo. Não apaga os dados.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Usuário desativado com sucesso (Sem conteúdo de retorno)"),
            @ApiResponse(responseCode = "404", description = "Usuário não encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class))),
            @ApiResponse(responseCode = "403", description = "Acesso negado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<Void> desativar(
            @Parameter(description = "ID do usuário a ser desativado", example = "650c...") @PathVariable String id
    ) {
        service.desativar(id);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/me")
    @Operation(summary = "Meu Perfil", description = "Retorna os dados detalhados do usuário atualmente logado (identificado pelo Token).")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Perfil retornado com sucesso",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UsuarioProfileDto.class))),
            @ApiResponse(responseCode = "403", description = "Token inválido ou conta desativada",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<UsuarioProfileDto> meuPerfil(Authentication authentication) {
        Usuario usuarioLogado = (Usuario) authentication.getPrincipal();
        return ResponseEntity.ok(service.buscarPorId(usuarioLogado.getId()));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Buscar por ID", description = "Busca o perfil de um usuário específico pelo ID.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Usuário encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = UsuarioProfileDto.class))),
            @ApiResponse(responseCode = "404", description = "Usuário não encontrado",
                    content = @Content(mediaType = "application/json", schema = @Schema(implementation = StandardError.class)))
    })
    public ResponseEntity<UsuarioProfileDto> buscarPorId(
            @Parameter(description = "ID do usuário", example = "650c...") @PathVariable String id
    ) {
        return ResponseEntity.ok(service.buscarPorId(id));
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\avaliacao\AvaliacaoRequestDto.java
============================================================
package br.com.lunix.dto.avaliacao;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Max;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

/*
   DTO utilizado para realizar o cadastro de avaliações para
   jogos.

   @NotNull - Garante que os campos não estejam vazios.
   @Min e @Max - Define um valor mínimo e máximo para a nota.
   @Size - Define um tamanho máximo para o comentário.
*/
public record AvaliacaoRequestDto(

        @NotNull(message = "Não se pode dar uma nota vazia")
        @Min(value = 0, message = "A nota deve ser maior que 0")
        @Max(value = 10, message = "A nota não pode ser mais de 10")
        @Schema(description = "Nota que deve ser atribuída ao jogo", example = "8.5")
        Integer nota,
        @Schema(description = "Comentário referente, dando motivo à avaliação", example = "Jogo muito bom! 10/10")
        @Size(max = 10000, message = "Número máximo de caracteres ultrapassado(10.000)")
        String comentario
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\avaliacao\AvaliacaoResponseDto.java
============================================================
package br.com.lunix.dto.avaliacao;

import br.com.lunix.dto.usuario.UsuarioPublicProfileDto;
import io.swagger.v3.oas.annotations.media.Schema;

import java.io.Serializable;
import java.time.LocalDateTime;

/*
    DTO utilizado para exibir a avaliação na
    página do jogo.
*/
public record AvaliacaoResponseDto(
        @Schema(description = "Identificador único da avaliação", example = "650c...")
        String id,
        @Schema(description = "Nota dada na avaliação", example = "8.5")
        int nota,
        @Schema(description = "Comentário inserido pelo usuário")
        String comentario,
        @Schema(description = "Data em que a avaliação foi postada", example = "2025-12-16")
        LocalDateTime dataCriacao,
        @Schema(description = "Usuário que realizou a avaliação")
        UsuarioPublicProfileDto usuario
) implements Serializable {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\dashboard\DashboardJogoDto.java
============================================================
package br.com.lunix.dto.dashboard;

import io.swagger.v3.oas.annotations.media.Schema;

import java.util.Map;

// Dto específico para o dashboard do admin
public record DashboardJogoDto(
        @Schema(description = "Total de jogos registrados na aplicação", example = "21")
        long totalJogos,
        // Campo útil para garantir que todos os jogos estão com o nome correto para a atualização automática
        @Schema(description = "Jogos que não tem preço cadastrado", example = "10")
        long totalJogosSemPreco,
        @Schema(description = "Quantidade de jogos que há de um certo gênero", example = "[ 'ACAO': 3 ]")
        Map<String, Long> jogosPorGenero,
        @Schema(description = "Quantidade de jogos que há de um certas plataformas", example = "[ 'PC': 5 ]")
        Map<String, Long> jogosPorPlataforma
) {}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\empresa\EmpresaDetalhesDto.java
============================================================
package br.com.lunix.dto.empresa;

import br.com.lunix.dto.jogos.JogoResponseDto;
import br.com.lunix.model.entities.Empresa;
import io.swagger.v3.oas.annotations.media.Schema;

import java.util.List;

/*
    DTO que trás detalhes sobre a empresa
    exibida
*/
public record EmpresaDetalhesDto(
        @Schema(description = "Identificador único da empresa", example = "650c...")
        String id,
        @Schema(description = "Nome da empresa desenvolvedora", example = "Team Cherry")
        String nome,
        @Schema(description = "Descrição da empresa cadastrada", example = "Empresa de pequeno porte da Austrália")
        String descricao,
        @Schema(description = "País onde foi criada a empresa/estúdio", example = "Austrália")
        String paisOrigem,
        @Schema(description = "URL para uma imagem da logo da empresa", example = "https://img.com")
        String urlLogo,
        @Schema(description = "Lista com os jogos pertencentes a empresa")
        List<JogoResponseDto> jogos
) {}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\empresa\EmpresaRequestDto.java
============================================================
package br.com.lunix.dto.empresa;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;

/*
   DTO utilizado para requisição no cadastro
   de uma empresa.

   @NotBlank - Garante que o campo não esteja vazio.
*/
public record EmpresaRequestDto(
        @NotBlank(message = "O nome da empresa não pode ser vazio")
        @Schema(description = "Nome da empresa desenvolvedora", example = "Team Cherry")
        String nome,
        @NotBlank(message = "A empresa deve ter uma descrição")
        @Schema(description = "Descrição da empresa cadastrada", example = "Empresa de pequeno porte da Austrália")
        String descricao,
        @NotBlank(message = "A empresa deve ter um país de origem definido")
        @Schema(description = "País onde foi criada a empresa/estúdio", example = "Austrália")
        String paisOrigem,
        @Schema(description = "URL para uma imagem da logo da empresa", example = "https://img.com")
        String urlLogo
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\empresa\EmpresaResponseDto.java
============================================================
package br.com.lunix.dto.empresa;

import io.swagger.v3.oas.annotations.media.Schema;

// DTO que mostra a empresa dados de uma empresa
public record EmpresaResponseDto(
        @Schema(description = "Identificador único da empresa", example = "650c...")
        String id,
        @Schema(description = "Nome da empresa desenvolvedora", example = "Team Cherry")
        String nome,
        @Schema(description = "País onde foi criada a empresa/estúdio", example = "Austrália")
        String paisOrigem,
        @Schema(description = "URL para uma imagem da logo da empresa", example = "https://img.com")
        String urlLogo) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\empresa\EmpresaUpdateDto.java
============================================================
package br.com.lunix.dto.empresa;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;

/*
    DTO utilizado para o formulário de atualização
    de dados de uma empresa.

    @NotBlank - Garante que o campo não seja vazio.
*/
public record EmpresaUpdateDto(
        @Schema(description = "Nome da empresa desenvolvedora", example = "Team Cherry")
        @NotBlank(message = "O nome da empresa não pode ser vazio")
        String nome,
        @NotBlank(message = "A empresa deve ter uma descrição")
        @Schema(description = "Descrição da empresa cadastrada", example = "Empresa de pequeno porte da Austrália")
        String descricao,
        @NotBlank(message = "A empresa deve ter um país de origem definido")
        @Schema(description = "País onde foi criada a empresa/estúdio", example = "Austrália")
        String paisOrigem,
        @Schema(description = "URL para uma imagem da logo da empresa", example = "https://img.com")
        String urlLogo
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\error\StandardError.java
============================================================
package br.com.lunix.dto.error;

import io.swagger.v3.oas.annotations.media.Schema;

import java.time.Instant;

public record StandardError(
        @Schema(description = "Momento que o erro ocorreu", example = "2025-12-12T20:49:23.637Z")
        Instant timestamp,
        @Schema(description = "Código de status", example = "404")
        Integer status,
        @Schema(description = "Tipo de erro encontrado", example = "Não encontrado")
        String error,
        @Schema(description = "Mensagem de erro", example = "Recurso não encontrado")
        String message,
        @Schema(description = "Caminho da origem do erro", example = "lunix/usuarios")
        String path
) {}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\itad\ItadRecords.java
============================================================
package br.com.lunix.dto.itad;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;
import java.util.List;

public class ItadRecords {

    // --- DTOs para o endpoint /games/lookup/v1 ---
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record ItadGameLookupDto(String id, String slug, String title) {}

    @JsonIgnoreProperties(ignoreUnknown = true)
    public record ItadLookupResponseDto(boolean found, ItadGameLookupDto game) {}

    /** Mapeia os objetos aninhados de preço ("price" e "regular"). */
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record ItadPriceDetailsDto(double amount, String currency) {}

    /** Mapeia o objeto "shop" que contém o ID e o nome da loja. */
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record ItadShopDto(int id, String name) {}

    /** Mapeia uma "deal" (oferta) individual. */
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record ItadDealDto(
            @JsonProperty("shop") ItadShopDto shop,
            @JsonProperty("price") ItadPriceDetailsDto price,
            @JsonProperty("regular") ItadPriceDetailsDto regular,
            @JsonProperty("cut") int priceCut,
            @JsonProperty("url") String url,
            @JsonProperty("drm") List<ItadDrmDto> drm
    ) {}

    /** Mapeia o objeto de preço de um único jogo, que contém seu ID e a lista de deals. */
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record ItadPriceResultDto(
            String id,
            @JsonProperty("deals") List<ItadDealDto> deals
    ) {}

    @JsonIgnoreProperties(ignoreUnknown = true)
    public record ItadDrmDto(
            int id,
            String name
    ) {}
}

============================================================
CAMINHO: src\main\java\br\com\lunix\dto\itad\ItadSearchRecords.java
============================================================
package br.com.lunix.dto.itad;


import com.fasterxml.jackson.annotation.JsonIgnoreProperties;

import java.util.List;

public class ItadSearchRecords {

    @JsonIgnoreProperties(ignoreUnknown = true)
    public record ItadSearchResultDto(
            String plain,
            String title
    ) {}

    @JsonIgnoreProperties(ignoreUnknown = true)
    public record ItadSearchDataDto(
            List<ItadSearchResultDto> list
    ) {}

    @JsonIgnoreProperties(ignoreUnknown = true)
    public record ItadSearchResponseDto(
            ItadSearchDataDto data
    ) {}
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\jogos\JogoAdminRequestDto.java
============================================================
package br.com.lunix.dto.jogos;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotNull;

public record JogoAdminRequestDto(
        @NotNull
        @Schema(description = "Informações do jogo a serem inseridas")
        JogoRequestDto jogoData,
        @Schema(description = "Identificador único de um desenvolvedor", example = "650c...")
        String devId,
        @Schema(description = "Identificador único de uma empresa", example = "789c...")
        String empresaIdExistente
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\jogos\JogoDetalhesDto.java
============================================================
package br.com.lunix.dto.jogos;

import br.com.lunix.dto.avaliacao.AvaliacaoResponseDto;
import br.com.lunix.model.entities.Jogo;
import br.com.lunix.model.entities.PrecoPlataforma;
import br.com.lunix.model.enums.ClassificacaoIndicativa;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import io.swagger.v3.oas.annotations.media.Schema;

import java.io.Serializable;
import java.time.LocalDate;
import java.util.List;

// Record para exibir os detalhes sobre um jogo.
public record JogoDetalhesDto(
        @Schema(description = "Identificador único do jogo", example = "650c...")
        String id,
        @Schema(description = "Título do jogo", example = "Hollow Knight")
        String titulo,
        @Schema(description = "Descrição do jogo", example = "Venha se abrigar em hallownest")
        String descricao,
        @Schema(description = "URL de imagem da capa do jogo", example = "https://img.com")
        String urlCapa,
        @Schema(description = "Data de lançamento do jogo", example = "2022-12-16")
        LocalDate dataLancamento,
        @Schema(description = "Classificação indicativa do jogo", example = "DEZ")
        ClassificacaoIndicativa classificacao,
        @Schema(description = "Lista com os gêneros do jogo", example = "[ 'PLATAFORMA', 'ACAO' ]")
        List<Genero> generos,
        @Schema(description = "Lista de lojas com o preço dos jogos nela")
        List<PrecoPlataforma> precos,
        @Schema(description = "Lista de plataformas que se dá para jogar", example = "[ 'PC', 'SWITCH' ]")
        List<Plataforma> plataformas,
        @Schema(description = "Nota média das avaliações do jogo", example = "9.2")
        double notaMedia,
        @Schema(description = "Quantidade total de avaliações do jogo", example = "40")
        int totalAvaliacoes,
        @Schema(description = "Nome do criador do jogo", example = "Team Cherry")
        String nomeCriador,
        @Schema(description = "Lista de avaliações dos administradores")
        List<AvaliacaoResponseDto> avaliacoesAdmin,
        @Schema(description = "Lista de avaliações dos usuários")
        List<AvaliacaoResponseDto> avaliacoesUsuario,
        @Schema(description = "Lista de avaliações de devs")
        List<AvaliacaoResponseDto> avaliacoesDev
) implements Serializable {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\jogos\JogoGenresPatchDto.java
============================================================
package br.com.lunix.dto.jogos;

import br.com.lunix.model.enums.Genero;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotEmpty;

import java.util.List;

/*
    Record usado para realizar um PATCH dos gêneros
    de um jogo.

    @NotBlank - Garante que o campo não seja nulo.
*/
public record JogoGenresPatchDto(
        @NotEmpty(message = "O jogo deve ter ao menos um genero")
        @Schema(description = "Lista com os gêneros do jogo", example = "[ 'PLATAFORMA', 'ACAO' ]")
        List<Genero> generos) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\jogos\JogoMapeadoDto.java
============================================================
package br.com.lunix.dto.jogos;

import br.com.lunix.model.entities.Jogo;
import io.swagger.v3.oas.annotations.media.Schema;

/*
    DTO responsável por receber o objeto mapeado
    pelo RawgMapper.
*/
public record JogoMapeadoDto(
        @Schema(description = "Jogo encontrado")
        Jogo jogo,
        @Schema(description = "Nome do desenvolvedor", example = "Team Cherry")
        String nomeDesenvolvedorPrincipal
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\jogos\JogoRequestDto.java
============================================================
package br.com.lunix.dto.jogos;

import br.com.lunix.annotation.interfaces.PastOrPresentDate;
import br.com.lunix.model.enums.ClassificacaoIndicativa;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;

import java.time.LocalDate;
import java.util.List;

/*
   DTO utilizado para realizar o cadastro de jogos.

   @NotBlank, @NotNull e @NotEmpty - Garante que os campos não estejam vazios.
   @PastOrPresentDate - Garante que uma data futura não seja inserida.
*/
public record JogoRequestDto(
        @NotBlank(message = "O título não pode estar vazio")
        @Schema(description = "Título do jogo", example = "Hollow Knight")
        String titulo,
        @NotBlank(message = "A descricao não pode estar vazia")
        @Schema(description = "Descrição do jogo", example = "Venha se abrigar em hallownest")
        String descricao,
        @Schema(description = "URL de imagem da capa do jogo", example = "https://img.com")
        String urlCapa,
        @NotNull(message = "A data de lançamento é obrigatória")
        @PastOrPresentDate
        @Schema(description = "Data de lançamento do jogo", example = "2022-12-16")
        LocalDate dataLancamento,
        @NotNull(message = "A classificacao indicativa é obrigatória")
        @Schema(description = "Classificação indicativa do jogo", example = "DEZ")
        ClassificacaoIndicativa classificacao,
        @NotEmpty(message = "Um jogo deve ter ao menos um Genero")
        @Schema(description = "Lista com os gêneros do jogo", example = "[ 'PLATAFORMA', 'ACAO' ]")
        List<Genero> generos,
        @NotEmpty(message = "Selecione ao menos uma plataforma.")
        @Schema(description = "Lista de plataformas que se dá para jogar", example = "[ 'PC', 'SWITCH' ]")
        List<Plataforma> plataformas
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\jogos\JogoResponseDto.java
============================================================
package br.com.lunix.dto.jogos;

import br.com.lunix.model.enums.ClassificacaoIndicativa;
import br.com.lunix.model.enums.Genero;
import io.swagger.v3.oas.annotations.media.Schema;

import java.io.Serializable;
import java.util.List;

// DTO de resposta para os jogos
public record JogoResponseDto(
        @Schema(description = "Identificador único do jogo", example = "650c...")
        String id,
        @Schema(description = "Título do jogo", example = "Hollow Knight")
        String titulo,
        @Schema(description = "URL de imagem da capa do jogo", example = "https://img.com")
        String urlCapa,
        @Schema(description = "Nome do criador do jogo", example = "Team Cherry")
        String nomeCriador,
        @Schema(description = "Nota média das avaliações do jogo", example = "9.2")
        double notaMedia,
        @Schema(description = "Lista com os gêneros do jogo", example = "[ 'PLATAFORMA', 'ACAO' ]")
        List<Genero> generos,
        @Schema(description = "Classificação indicativa do jogo", example = "DEZ")
        ClassificacaoIndicativa classificacao
) implements Serializable {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\jogos\JogoUpdateDto.java
============================================================
package br.com.lunix.dto.jogos;

import br.com.lunix.annotation.interfaces.PastOrPresentDate;
import br.com.lunix.model.enums.ClassificacaoIndicativa;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;

import java.time.LocalDate;
import java.util.List;

/*
   DTO utilizado para realizar o update de jogos.

   @NotBlank, @NotNull e @NotEmpty - Garante que os campos não estejam vazios.
   @PastOrPresentDate - Garante que uma data futura não seja inserida.
*/
public record JogoUpdateDto(
        @NotBlank(message = "O título não pode estar vazio")
        @Schema(description = "Título do jogo", example = "Hollow Knight")
        String titulo,
        @NotBlank(message = "A descricao não pode estar vazia")
        @Schema(description = "Descrição do jogo", example = "Venha se abrigar em hallownest")
        String descricao,
        @Schema(description = "URL de imagem da capa do jogo", example = "https://img.com")
        String urlCapa,
        @NotNull(message = "A data de lançamento é obrigatória")
        @PastOrPresentDate
        @Schema(description = "Data de lançamento do jogo", example = "2022-12-16")
        LocalDate dataLancamento,
        @NotNull(message = "A classificacao indicativa é obrigatória")
        @Schema(description = "Classificação indicativa do jogo", example = "DEZ")
        ClassificacaoIndicativa classificacao,
        @NotEmpty(message = "Um jogo deve ter ao menos um Genero")
        @Schema(description = "Lista com os gêneros do jogo", example = "[ 'PLATAFORMA', 'ACAO' ]")
        List<Genero> generos,
        @NotEmpty(message = "Selecione ao menos uma plataforma.")
        @Schema(description = "Lista de plataformas que se dá para jogar", example = "[ 'PC', 'SWITCH' ]")
        List<Plataforma> plataformas
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\rawg\RawgRecords.java
============================================================
package br.com.lunix.dto.rawg;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonProperty;

import java.time.LocalDate;
import java.util.List;

/*
    Classe que comporta diversos records para utilização
    de recebimento de dados da API RawgIo.
*/
public class RawgRecords {

    // Record que recebe o gênero do jogo
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record RawgGenreDto(int id, String name, String slug) {}

    // Record que recebe o nome do desenvolvedor
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record RawgDeveloperDto(int id, String name, String slug) {}

    // Mapeia o objeto "platform" interno.
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record RawgPlatformDto(int id, String name, String slug) {}

    // Mapeia a entrada principal na lista "platforms", que contém o objeto aninhado.
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record RawgPlatformEntryDto(@JsonProperty("platform") RawgPlatformDto platform) {}

    // Record final que recebe todos os dados necessários
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record RawgGameDto(
            int id,
            String slug,
            @JsonProperty("name") String name,
            @JsonProperty("released") LocalDate released,
            @JsonProperty("background_image") String backgroundImage,
            @JsonProperty("esrb_rating") RawgEsrbRatingDto esrbRating,
            @JsonProperty("platforms") List<RawgPlatformEntryDto> platforms,
            @JsonProperty("genres") List<RawgGenreDto> genres,
            @JsonProperty("developers") List<RawgDeveloperDto> developers,
            @JsonProperty("description_raw") String description
    ) {}

    // Record que recebe a lista de jogos encontrados
    public record RawgApiResponseDto(
            int count,
            String next,
            String previous,
            List<RawgGameDto> results
    ) {}

    // Record para mapear a classificação indicativa dos jogos
    @JsonIgnoreProperties(ignoreUnknown = true)
    public record RawgEsrbRatingDto(int id, String name, String slug) {}
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\usuario\TokenResponseDto.java
============================================================
package br.com.lunix.dto.usuario;

import io.swagger.v3.oas.annotations.media.Schema;

public record TokenResponseDto(
        @Schema(
                description = "Token de autenticação JWT (Bearer)",
                example = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJhZG1pbkBsdW5pe..."
        )
        String token
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\usuario\UsuarioAdminListDto.java
============================================================
package br.com.lunix.dto.usuario;

import br.com.lunix.model.enums.Role;
import io.swagger.v3.oas.annotations.media.Schema;

import java.util.Set;

/*
    DTO utilizado para exibir os usuários da aplicação
    para o ADMIN conseguir ter controle.
*/
public record UsuarioAdminListDto(
        @Schema(description = "ID do usuário", example = "69dg587ty1...")
        String id,
        @Schema(description = "E-mail cadastrado", example = "admin@lunix.com")
        String email,
        @Schema(description = "Roles de permissão do usuário", example = "ROLE_USER")
        Set<Role> roles,
        @Schema(description = "Status do usuário", example = "true")
        Boolean ativo,
        @Schema(description = "ID da empresa pertencente do usuário", example = "6985chji145...")
        String idEmpresa,
        @Schema(description = "Nome da empresa do usuário", example = "Team Cherry")
        String nomeEmpresa
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\usuario\UsuarioLoginDto.java
============================================================
package br.com.lunix.dto.usuario;

import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

/*
   DTO utilizado para o formulário de login.

   @NotBlank - Mostra que o campo não pode estar vazio.
   @Email - Indica maneira com que o email deve ser formatado.
*/
public record UsuarioLoginDto(
        @Schema(description = "E-mail cadastrado", example = "admin@lunix.com")
        @NotBlank(message = "O campo email deve ser preenchido")
        @Email(message = "Por favor insira um email válido")
        String email,

        @Schema(description = "Senha do usuário", example = "12345678")
        @NotBlank(message = "A senha não pode ser vazia")
        String senha
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\usuario\UsuarioProfileDto.java
============================================================
package br.com.lunix.dto.usuario;

import br.com.lunix.dto.empresa.EmpresaResponseDto;
import io.swagger.v3.oas.annotations.media.Schema;

/*
    DTO utilizado para a área de perfil do
    usuário.
*/
public record UsuarioProfileDto(
        @Schema(description = "ID do usuário", example = "69dg587ty1...")
        String id,
        @Schema(description = "Nome do usuário", example = "João")
        String nome,
        @Schema(description = "E-mail cadastrado", example = "admin@lunix.com")
        String email,
        EmpresaResponseDto empresa
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\usuario\UsuarioPublicProfileDto.java
============================================================
package br.com.lunix.dto.usuario;

import io.swagger.v3.oas.annotations.media.Schema;

import java.io.Serializable;

// DTO para o perfil público de um usuário.
public record UsuarioPublicProfileDto(
        @Schema(description = "ID do usuário", example = "69dg587ty1...")
        String id,
        @Schema(description = "Nome do usuário", example = "João")
        String nome
) implements Serializable {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\usuario\UsuarioRegistroDto.java
============================================================
package br.com.lunix.dto.usuario;

import br.com.lunix.annotation.interfaces.PasswordsMatch;
import br.com.lunix.annotation.interfaces.UniqueEmail;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

/*
   DTO utilizado para o cadastro de usuários
   na aplicação.

   @PasswordsMatch - Garante que o campo de senha e confirmação de senha sejam iguais
   @NotBlank - Indica que o campo não deve estar vazio.
   @Email - Define o formato que deve ser utilizado no email.
   @UniqueEmail - Garante que o email já não esteja registrado no banco.
   @Size - Define o tamanho mínimo a se ter em um campo.
*/
@PasswordsMatch
public record UsuarioRegistroDto(
        @Schema(description = "Nome do usuário", example = "João")
        @NotBlank(message = "O nome é obrigatório.")
        String nome,

        @Schema(description = "E-mail cadastrado", example = "admin@lunix.com")
        @NotBlank(message = "O e-mail é obrigatório.")
        @Email(message = "Por favor, insira um e-mail válido.")
        @UniqueEmail
        String email,

        @Schema(description = "Senha do usuário", example = "12345678")
        @NotBlank(message = "A senha é obrigatória.")
        @Size(min = 8, message = "A senha deve ter no mínimo 8 caracteres.")
        String senha,

        @Schema(description = "Confirmação da senha", example = "12345678")
        @NotBlank(message = "A confirmação de senha é obrigatória.")
        String confirmacaoSenha,
        @Schema(description = "ID da empresa pertencente do usuário", example = "6985chji145...")
        String idEmpresa
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\usuario\UsuarioRolePatchDto.java
============================================================
package br.com.lunix.dto.usuario;

import br.com.lunix.model.enums.Role;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotEmpty;

import java.util.Set;

/*
    DTO para se utilizar no método de PATCH
    para a alteração dos cargos de um usuário.

    @NotEmpty - Indica que o campo não pode estar
    vazio.
*/
public record UsuarioRolePatchDto(
        @Schema(description = "Role do usuário", example = "[ ROLE_USER ]")
        @NotEmpty(message = "O usuário deve ter uma Role")
        Set<Role> roles
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\dto\usuario\UsuarioUpdateDto.java
============================================================
package br.com.lunix.dto.usuario;

import br.com.lunix.model.enums.Role;
import io.swagger.v3.oas.annotations.media.Schema;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotEmpty;
import jakarta.validation.constraints.NotNull;

import java.util.Set;

/*
    DTO utilizado para atualização de usuários.

    @NotBlack e @NotNull - Anotações que garantem que o campo
    não esteja vazio.
*/
public record UsuarioUpdateDto(
        @Schema(description = "Nome do usuário", example = "João")
        @NotBlank(message = "O nome não pode ser vazio")
        String nome,
        @Schema(description = "Role do usuário", example = "[ ROLE_USER ]")
        @NotEmpty(message = "O usuário deve ter uma Role")
        Set<Role> roles,
        @Schema(description = "Status do usuário", example = "true")
        @NotNull(message = "É necessário dizer se o usuário é ativo ou não")
        Boolean ativo,
        @Schema(description = "ID da empresa pertencente do usuário", example = "6985chji145...")
        String idEmpresa
) {
}


============================================================
CAMINHO: src\main\java\br\com\lunix\exceptions\GlobalExceptionHandler.java
============================================================
package br.com.lunix.exceptions;

import br.com.lunix.dto.error.StandardError;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;

import java.time.Instant;
import java.util.stream.Collectors;

@ControllerAdvice
public class GlobalExceptionHandler {

    // Tratamento para recurso não encontrado (404)
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<StandardError> resourceNotFound(ResourceNotFoundException e, HttpServletRequest request) {
        String error = "Recurso não encontrado";
        HttpStatus status = HttpStatus.NOT_FOUND;
        StandardError err = new StandardError(Instant.now(), status.value(), error, e.getMessage(), request.getRequestURI());
        return ResponseEntity.status(status).body(err);
    }

    @ExceptionHandler(JogoNaoIndieException.class)
    public ResponseEntity<StandardError> notIndieGame(JogoNaoIndieException e, HttpServletRequest request) {
        String error = "Jogo não listado não é indie";
        HttpStatus status = HttpStatus.NOT_FOUND;
        StandardError err = new StandardError(Instant.now(), status.value(), error, e.getMessage(), request.getRequestURI());
        return ResponseEntity.status(status).body(err);
    }

    // Tratamento para regras de negócio (400) - Ex: Email já cadastrado
    @ExceptionHandler(RegraDeNegocioException.class)
    public ResponseEntity<StandardError> businessRule(RegraDeNegocioException e, HttpServletRequest request) {
        String error = "Erro de regra de negócio";
        HttpStatus status = HttpStatus.BAD_REQUEST;
        StandardError err = new StandardError(Instant.now(), status.value(), error, e.getMessage(), request.getRequestURI());
        return ResponseEntity.status(status).body(err);
    }

    // Tratamento para validação de campos (@Valid) nos DTOs (422 ou 400)
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<StandardError> validation(MethodArgumentNotValidException e, HttpServletRequest request) {
        String error = "Erro de validação";
        HttpStatus status = HttpStatus.UNPROCESSABLE_ENTITY;

        // Pega todas as mensagens de erro dos campos e junta numa string
        String message = e.getBindingResult().getFieldErrors().stream()
                .map(fieldError -> fieldError.getField() + ": " + fieldError.getDefaultMessage())
                .collect(Collectors.joining("; "));

        StandardError err = new StandardError(Instant.now(), status.value(), error, message, request.getRequestURI());
        return ResponseEntity.status(status).body(err);
    }

    // Tratamento para erro de autenticação (401) - Login errado
    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<StandardError> badCredentials(BadCredentialsException e, HttpServletRequest request) {
        String error = "Erro de autenticação";
        HttpStatus status = HttpStatus.UNAUTHORIZED;
        StandardError err = new StandardError(Instant.now(), status.value(), error, "Credenciais inválidas", request.getRequestURI());
        return ResponseEntity.status(status).body(err);
    }

    // Tratamento para conta desativada (403)
    @ExceptionHandler(DisabledException.class)
    public ResponseEntity<StandardError> accountDisabled(DisabledException e, HttpServletRequest request) {
        String error = "Conta desativada";
        HttpStatus status = HttpStatus.FORBIDDEN;

        StandardError err = new StandardError(
                Instant.now(),
                status.value(),
                error,
                "Sua conta foi desativada. Entre em contato com o suporte.",
                request.getRequestURI()
        );

        return ResponseEntity.status(status).body(err);
    }

    // Tratamento para acesso negado (403)
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<StandardError> accessDenied(AccessDeniedException e, HttpServletRequest request) {
        String error = "Acesso negado";
        HttpStatus status = HttpStatus.FORBIDDEN;
        StandardError err = new StandardError(Instant.now(), status.value(), error, "Você não tem permissão para acessar este recurso", request.getRequestURI());
        return ResponseEntity.status(status).body(err);
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\exceptions\JogoNaoIndieException.java
============================================================
package br.com.lunix.exceptions;

public class JogoNaoIndieException extends RuntimeException {
    public JogoNaoIndieException(String message) {
        super(message);
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\exceptions\RegraDeNegocioException.java
============================================================
package br.com.lunix.exceptions;

public class RegraDeNegocioException extends RuntimeException {
    public RegraDeNegocioException(String message) {
        super(message);
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\exceptions\ResourceNotFoundException.java
============================================================
package br.com.lunix.exceptions;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\mapper\AvaliacaoMapper.java
============================================================
package br.com.lunix.mapper;

import br.com.lunix.dto.avaliacao.AvaliacaoRequestDto;
import br.com.lunix.dto.avaliacao.AvaliacaoResponseDto;
import br.com.lunix.dto.usuario.UsuarioPublicProfileDto;
import br.com.lunix.model.entities.Avaliacao;
import org.springframework.stereotype.Component;

@Component
public class AvaliacaoMapper {

    private final UsuarioMapper usuarioMapper;

    public AvaliacaoMapper(UsuarioMapper usuarioMapper) {
        this.usuarioMapper = usuarioMapper;
    }

    /*
      Converte o DTO de requisição para a Entidade.
      OBS: Não setamos Usuário nem Jogo aqui, pois o RequestDto não traz esses IDs.
      Eles serão pegos do Token (Usuário) e da URL (Jogo) na Service.
    */
    public Avaliacao toEntity(AvaliacaoRequestDto dto) {
        if (dto == null) return null;

        Avaliacao avaliacao = new Avaliacao();
        avaliacao.setNota(dto.nota());
        avaliacao.setComentario(dto.comentario());

        return avaliacao;
    }

    /*
      Converte a Entidade para o DTO de resposta.
      Usa o UsuarioMapper para converter o autor da avaliação.
    */
    public AvaliacaoResponseDto toResponseDto(Avaliacao entity) {
        if (entity == null) return null;

        UsuarioPublicProfileDto usuarioDto = usuarioMapper.toPublicProfileDto(entity.getUsuario());

        return new AvaliacaoResponseDto(
                entity.getId(),
                entity.getNota(),
                entity.getComentario(),
                entity.getDataCriacao(),
                usuarioDto
        );
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\mapper\EmpresaMapper.java
============================================================
package br.com.lunix.mapper;

import br.com.lunix.dto.empresa.EmpresaDetalhesDto;
import br.com.lunix.dto.empresa.EmpresaRequestDto;
import br.com.lunix.dto.empresa.EmpresaResponseDto;
import br.com.lunix.dto.empresa.EmpresaUpdateDto;
import br.com.lunix.dto.jogos.JogoResponseDto;
import br.com.lunix.model.entities.Empresa;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class EmpresaMapper {

    /*
      Converte o DTO de criação para a Entidade Empresa.
    */
    public Empresa toEntity(EmpresaRequestDto dto) {
        if (dto == null) return null;

        Empresa empresa = new Empresa();
        empresa.setNome(dto.nome());
        empresa.setDescricao(dto.descricao());
        empresa.setPaisOrigem(dto.paisOrigem());
        empresa.setUrlLogo(dto.urlLogo());

        return empresa;
    }

    /*
      Atualiza uma empresa existente com os dados do formulário de update.
    */
    public void updateEntityFromDto(EmpresaUpdateDto dto, Empresa empresa) {
        if (dto == null || empresa == null) return;

        empresa.setNome(dto.nome());
        empresa.setDescricao(dto.descricao());
        empresa.setPaisOrigem(dto.paisOrigem());

        empresa.setUrlLogo(dto.urlLogo());
    }

    /*
      Retorna o DTO padrão de resposta (para listas, selects, etc).
    */
    public EmpresaResponseDto toResponseDto(Empresa empresa) {
        if (empresa == null) return null;

        return new EmpresaResponseDto(
                empresa.getId(),
                empresa.getNome(),
                empresa.getPaisOrigem(),
                empresa.getUrlLogo()
        );
    }

    /*
      Monta o DTO de detalhes, que inclui a empresa e a lista de jogos dela.
    */
    public EmpresaDetalhesDto toDetalhesDto(Empresa empresa, List<JogoResponseDto> jogos) {
        if (empresa == null) return null;

        return new EmpresaDetalhesDto(
                empresa.getId(),
                empresa.getNome(),
                empresa.getDescricao(),
                empresa.getPaisOrigem(),
                empresa.getUrlLogo(),
                jogos
        );
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\mapper\ItadMapper.java
============================================================
package br.com.lunix.mapper;

import br.com.lunix.dto.itad.ItadRecords.ItadDealDto;
import br.com.lunix.model.entities.PrecoPlataforma;
import org.springframework.stereotype.Component;

/*
    Componente responsável por receber um DTO da API
    ITAD e converter para um objeto do tipo PrecoPlataforma
*/
@Component
public class ItadMapper {

    /*
        Método responsável por fazer a conversão dos dados
        recebidos em um objeto PrecoPlataforma.

        @param dto: Dados da api para serem convertidos.

        @return: Retorna um objeto do tipo PrecoPLataforma.
    */
    public PrecoPlataforma toPrecoPlataforma(ItadDealDto dto) {
        if (dto == null) {
            return null;
        }

        // Caso o campo 'price' esteja vazio o valor fica 0
        double precoAtual = (dto.price() != null) ? dto.price().amount() : 0.0;

        // Caso o campo 'regular' esteja vazio adota o mesmo valor de 'precoAtual'
        double precoBase = (dto.regular() != null) ? dto.regular().amount() : precoAtual;

        return new PrecoPlataforma(
                dto.shop().name(),
                precoAtual,
                precoBase,
                dto.priceCut(),
                dto.url()
        );
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\mapper\JogoMapper.java
============================================================
package br.com.lunix.mapper;

import br.com.lunix.dto.avaliacao.AvaliacaoResponseDto;
import br.com.lunix.dto.jogos.*;
import br.com.lunix.model.entities.Jogo;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.List;

@Component
public class JogoMapper {

    /*
      Converte o DTO de cadastro básico para a Entidade.
      OBS: Empresa e DevAutonomo são definidos na Service (via Token ou Admin DTO).
    */
    public Jogo toEntity(JogoRequestDto dto) {
        if (dto == null) return null;

        Jogo jogo = new Jogo();
        jogo.setTitulo(dto.titulo());
        jogo.setDescricao(dto.descricao());
        jogo.setUrlCapa(dto.urlCapa());
        jogo.setDataLancamento(dto.dataLancamento());
        jogo.setClassificacao(dto.classificacao());
        jogo.setGeneros(dto.generos());
        jogo.setPlataformas(dto.plataformas());

        // Valores padrão de inicialização
        jogo.setNotaMedia(0.0);
        jogo.setTotalAvaliacoes(0);
        jogo.setPrecos(Collections.emptyList());

        return jogo;
    }

    /*
      Atualiza dados de um jogo existente.
    */
    public void updateEntityFromDto(JogoUpdateDto dto, Jogo jogo) {
        if (dto == null || jogo == null) return;

        jogo.setTitulo(dto.titulo());
        jogo.setDescricao(dto.descricao());
        jogo.setUrlCapa(dto.urlCapa());
        jogo.setDataLancamento(dto.dataLancamento());
        jogo.setClassificacao(dto.classificacao());

        if (dto.generos() != null && !dto.generos().isEmpty()) {
            jogo.setGeneros(dto.generos());
        }

        if (dto.plataformas() != null && !dto.plataformas().isEmpty()) {
            jogo.setPlataformas(dto.plataformas());
        }
    }

    /*
      Atualiza apenas os gêneros (PATCH).
    */
    public void updateGeneros(JogoGenresPatchDto dto, Jogo jogo) {
        if (dto != null && jogo != null && dto.generos() != null) {
            jogo.setGeneros(dto.generos());
        }
    }

    /*
      DTO leve para listagens (Home Page).
    */
    public JogoResponseDto toResponseDto(Jogo jogo) {
        if (jogo == null) return null;

        return new JogoResponseDto(
                jogo.getId(),
                jogo.getTitulo(),
                jogo.getUrlCapa(),
                determinarNomeCriador(jogo),
                jogo.getNotaMedia(),
                jogo.getGeneros(),
                jogo.getClassificacao()
        );
    }

    /*
      DTO detalhado para a página do jogo.
      A Service deve buscá-las no AvaliacaoRepository, convertê-las e passá-las para este método.
    */
    public JogoDetalhesDto toDetalhesDto(
            Jogo jogo,
            List<AvaliacaoResponseDto> avAdmin,
            List<AvaliacaoResponseDto> avDev,
            List<AvaliacaoResponseDto> avUser
    ) {
        if (jogo == null) return null;

        return new JogoDetalhesDto(
                jogo.getId(),
                jogo.getTitulo(),
                jogo.getDescricao(),
                jogo.getUrlCapa(),
                jogo.getDataLancamento(),
                jogo.getClassificacao(),
                jogo.getGeneros(),
                jogo.getPrecos() != null ? jogo.getPrecos() : Collections.emptyList(),
                jogo.getPlataformas(),
                jogo.getNotaMedia(),
                jogo.getTotalAvaliacoes(),
                determinarNomeCriador(jogo),
                avAdmin != null ? avAdmin : Collections.emptyList(),
                avUser != null ? avUser : Collections.emptyList(),
                avDev != null ? avDev : Collections.emptyList()
        );
    }

    /*
      Define quem deve aparecer como "Criador": A Empresa ou o Dev Autônomo.
    */
    private String determinarNomeCriador(Jogo jogo) {
        if (jogo.getEmpresa() != null) {
            return jogo.getEmpresa().getNome();
        } else if (jogo.getDevAutonomo() != null) {
            return jogo.getDevAutonomo().getNome();
        }
        return "Desconhecido";
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\mapper\RawgMapper.java
============================================================
package br.com.lunix.mapper;

import br.com.lunix.dto.jogos.JogoMapeadoDto;
import br.com.lunix.dto.rawg.RawgRecords.*;
import br.com.lunix.model.entities.Jogo;
import br.com.lunix.model.enums.ClassificacaoIndicativa;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

/*
    Componente responsável por realizar o mapeamento
    de dados vindos da API da RAWG em entidades da aplicação.

    Possui métodos de tradução de dados da API para ENUMS,
    transformação de dados em listas dentre outros
*/
@Component
public class RawgMapper {

    private static final Logger log = LoggerFactory.getLogger(RawgMapper.class);

    /*
        Método principal que pega todos os dados encontrados
        e os transforma em uma entidade JogoMapeadoDto.

        @param dto: Resposta da api a ser transformada.
        @return: Retorna um record com o jogo mapeado.
    */
    public JogoMapeadoDto toJogoMapeado(RawgGameDto dto) {
        if (dto == null) {
            return null;
        }

        Jogo jogo = new Jogo();
        jogo.setTitulo(dto.name());
        jogo.setDescricao(dto.description());
        jogo.setDataLancamento(dto.released());
        jogo.setUrlCapa(dto.backgroundImage());

        // Mapeia as listas, traduzindo os valores da API para nossos Enums
        jogo.setGeneros(toGeneroList(dto.genres()));
        jogo.setPlataformas(toPlataformaList(dto.platforms()));
        jogo.setClassificacao(toClassificacaoIndicativa(dto.esrbRating()));

        String nomeDev = extrairNomeDesenvolvedorPrincipal(dto.developers());

        return new JogoMapeadoDto(jogo, nomeDev);
    }

    /*
        Método privado que extrai o nome do desenvolvedor
        da resposta da API.

        @param devDtos: Lista com os desenvolvedores do jogo.

        @return: Retorna uma única String com o nome do desenvolvedor
        principal do jogo. Em caso de falha devolve nulo.
    */
    private String extrairNomeDesenvolvedorPrincipal(List<RawgDeveloperDto> devDtos) {
        return Optional.ofNullable(devDtos)
                .filter(list -> !list.isEmpty()) // Fiotra a lista garantindo que não esteja vazia.
                .map(list -> list.get(0).name()) // Mapeia a lista para pegar o primeiro nome que aparece.
                .orElse(null);
    }

    /*
        Método privado que pega a lista de Generos recebida
        da API e a transforma em uma lista de ENUMS referente a
        nossa aplicação.

        @param generoDtos: Lista de Generos recebida da API.

        @return: Retorna uma lista transformada com todos os gêneros
        do jogo específico.
    */
    private List<Genero> toGeneroList(List<RawgGenreDto> generoDtos) {
        if (generoDtos == null) return Collections.emptyList(); // Em caso de lista vazia, retornar nulo.

        // Faz o mapeamento do objeto para transformar em itens do ENUM Genero.
        return generoDtos.stream().map(this::toGenero).filter(Objects::nonNull).collect(Collectors.toList());
    }

    /*
        Método privado responsável por transformar uma lista
        de plataformas recebidas da API em objetos ENUM do tipo
        Plataforma.

        @param plataformaDtos: Lista de plataformas recebidas para realizar a
        conversão.

        @return: Retorna a lista convertida de Plataforma.
    */
    private List<Plataforma> toPlataformaList(List<RawgPlatformEntryDto> plataformaDtos) {
        if (plataformaDtos == null) return Collections.emptyList(); // Caso esteja vazia retorna nulo.

        // Faz o mapeamento do objeto e transforma no objeto Plataforma.
        return plataformaDtos.stream().map(entry -> toPlataforma(entry.platform())).filter(Objects::nonNull).collect(Collectors.toList());
    }

    /*
        Pega maior parte das respostas esperadas da API
        e traduz para ENUMS da aplicação.

        Caso não encontre alguma define como 'OUTRO'.
    */
    private Genero toGenero(RawgGenreDto dto) {
        if (dto == null || dto.slug() == null) return null;
        return switch (dto.slug()) {
            case "action" -> Genero.ACAO;
            case "adventure" -> Genero.AVENTURA;
            case "role-playing-games-rpg" -> Genero.RPG;
            case "strategy" -> Genero.ESTRATEGIA;
            case "shooter" -> Genero.SHOOTER;
            case "simulation" -> Genero.SIMULACAO;
            case "puzzle" -> Genero.PUZZLE;
            case "platformer" -> Genero.PLATAFORMA;
            case "racing" -> Genero.CORRIDA;
            case "sports" -> Genero.ESPORTES;
            case "fighting" -> Genero.LUTA;
            case "horror" -> Genero.TERROR;
            case "survival" -> Genero.SURVIVAL;
            default -> {
                log.warn("Gênero não mapeado da API RAWG, categorizado como OUTROS: slug='{}', name='{}'", dto.slug(), dto.name());
                yield Genero.OUTROS;
            }
        };
    }

    /*
        Método que pega respostas esperadas de plataformas
        e traduz para o ENUM Plataforma.

        Caso não encontre cai no Enum 'OUTRO'.
    */
    private Plataforma toPlataforma(RawgPlatformDto dto) {
        if (dto == null || dto.slug() == null) return null;
        return switch (dto.slug()) {
            case "pc" -> Plataforma.PC;
            case "playstation5" -> Plataforma.PLAYSTATION_5;
            case "playstation4" -> Plataforma.PLAYSTATION_4;
            case "playstation3" -> Plataforma.PLAYSTATION_3;
            case "playstation2" -> Plataforma.PLAYSTATION_2;
            case "playstation1" -> Plataforma.PLAYSTATION_1;
            case "xbox-series-x" -> Plataforma.XBOX_SERIES;
            case "xbox-one" -> Plataforma.XBOX_ONE;
            case "xbox360" -> Plataforma.XBOX360;
            case "nintendo-switch" -> Plataforma.NINTENDO_SWITCH;
            case "nintendo-3ds" -> Plataforma.NINTENDO_3DS;
            case "nintendo-ds" -> Plataforma.NINTENDO_DS;
            case "macos" -> Plataforma.MACOS;
            case "linux" -> Plataforma.LINUX;
            case "android" -> Plataforma.ANDROID;
            case "ios" -> Plataforma.IOS;
            default -> {
                log.warn("Plataforma não mapeada da API RAWG, categorizada como OUTROS: slug='{}', name='{}'", dto.slug(), dto.name());
                yield Plataforma.OUTROS;
            }
        };
    }

    /*
        Método que traduz as classificações indicativas
        recebidas pela API e traduz para o objetos do Enum
        ClassificacaoIndicativa.
    */
    private ClassificacaoIndicativa toClassificacaoIndicativa(RawgEsrbRatingDto dto) {
        if (dto == null || dto.slug() == null) return null;
        return switch (dto.slug()) {
            case "everyone" -> ClassificacaoIndicativa.LIVRE;
            case "everyone-10-plus" -> ClassificacaoIndicativa.DEZ;
            case "teen" -> ClassificacaoIndicativa.DOZE;
            case "mature" -> ClassificacaoIndicativa.DEZESSEIS;
            case "adults-only" -> ClassificacaoIndicativa.DEZOITO;
            default -> null;
        };
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\mapper\UsuarioMapper.java
============================================================
package br.com.lunix.mapper;

import br.com.lunix.dto.empresa.EmpresaResponseDto;
import br.com.lunix.dto.usuario.*;
import br.com.lunix.model.entities.Usuario;
import br.com.lunix.model.enums.Role;
import org.springframework.stereotype.Component;

@Component
public class UsuarioMapper {

    public Usuario toEntity(UsuarioRegistroDto dto) {
        if (dto == null) return null;

        Usuario usuario = new Usuario();
        usuario.setNome(dto.nome());
        usuario.setEmail(dto.email());
        usuario.setSenha(dto.senha());

        // Padrões de inicialização
        usuario.setAtivo(true);
        usuario.getRoles().add(Role.ROLE_USER);
        return usuario;
    }

    public void updateEntityFromDto(UsuarioUpdateDto dto, Usuario usuario) {
        if (dto == null || usuario == null) return;

        usuario.setNome(dto.nome());

        if (dto.ativo() != null) {
            usuario.setAtivo(dto.ativo());
        }

        if (dto.roles() != null && !dto.roles().isEmpty()) {
            usuario.setRoles(dto.roles());
        }
    }

    public UsuarioProfileDto toProfileDto(Usuario usuario) {
        if (usuario == null) return null;

        EmpresaResponseDto empresaDto = null;

        if (usuario.getEmpresa() != null) {
            empresaDto = new EmpresaResponseDto(
                    usuario.getEmpresa().getId(),
                    usuario.getEmpresa().getNome(),
                    usuario.getEmpresa().getPaisOrigem(),
                    usuario.getEmpresa().getUrlLogo()
            );
        }
        return new UsuarioProfileDto(
                usuario.getId(),
                usuario.getNome(),
                usuario.getEmail(),
                empresaDto
        );
    }

    public UsuarioPublicProfileDto toPublicProfileDto(Usuario usuario) {
        if (usuario == null) return null;

        return new UsuarioPublicProfileDto(
                usuario.getId(),
                usuario.getNome()
        );
    }

    public UsuarioAdminListDto toAdminListDto(Usuario usuario) {
        if (usuario == null) return null;

        String idEmpresa = null;
        String nomeEmpresa = null;

        if (usuario.getEmpresa() != null) {
            idEmpresa = usuario.getEmpresa().getId();
            nomeEmpresa = usuario.getEmpresa().getNome();
        }

        return new UsuarioAdminListDto(
                usuario.getId(),
                usuario.getEmail(),
                usuario.getRoles(),
                usuario.isAtivo(),
                idEmpresa,
                nomeEmpresa
        );
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\model\entities\Avaliacao.java
============================================================
package br.com.lunix.model.entities;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.DBRef;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.LocalDateTime;


/*
    Entidade do banco de dados que receberá as avaliações
    feitas de um usuário a um jogo

    @Document - Define a classe como uma entidade no MongoDB.
    @Getter @Setter - Cria todos os getters e setters da classe.
    @NoArgsConstructor @AllArgsConstructor - Anotações que criam
    automaticamente os construtores pricipais da classe.
*/
@Document(collection = "avaliacoes")
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
public class Avaliacao {

    @Id
    private String id;

    @DBRef
    private Usuario usuario;

    @DBRef
    private Jogo jogo;

    private int nota;

    private String comentario;

    private LocalDateTime dataCriacao = LocalDateTime.now();
}


============================================================
CAMINHO: src\main\java\br\com\lunix\model\entities\Empresa.java
============================================================
package br.com.lunix.model.entities;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.LocalDateTime;


/*
    Entidade do banco de dados que receberá os dados
    das empresas que produziram os jogos

    @Document - Define a classe como uma entidade no MongoDB.
    @Getter @Setter - Cria todos os getters e setters da classe.
    @NoArgsConstructor @AllArgsConstructor - Anotações que criam
    automaticamente os construtores pricipais da classe.
*/
@Document(collection = "empresas")
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
public class Empresa {

    @Id
    private String id;

    private String nome;

    private String descricao;

    private String paisOrigem;

    private String urlLogo;

    private LocalDateTime dataCriacao = LocalDateTime.now();
}


============================================================
CAMINHO: src\main\java\br\com\lunix\model\entities\Jogo.java
============================================================
package br.com.lunix.model.entities;

import br.com.lunix.model.enums.ClassificacaoIndicativa;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.DBRef;
import org.springframework.data.mongodb.core.mapping.Document;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;


/*
    Entidade do banco de dados que receberá dados dos jogos
    que estarãp presentes na aplicação.

    @Document - Define a classe como uma entidade no MongoDB.
    @Getter @Setter - Cria todos os getters e setters da classe.
    @NoArgsConstructor @AllArgsConstructor - Anotações que criam
    automaticamente os construtores pricipais da classe.
*/
@Document(collection = "jogos")
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
public class Jogo {

    @Id
    private String id;

    private String titulo;

    private String descricao;

    private String urlCapa;

    private ClassificacaoIndicativa classificacao;

    private List<Genero> generos = new ArrayList<>();

    private List<PrecoPlataforma> precos = new ArrayList<>();

    private List<Plataforma> plataformas = new ArrayList<>();

    private double notaMedia = 0.0;

    private int totalAvaliacoes = 0;

    @DBRef
    private Empresa empresa;

    @DBRef
    private Usuario devAutonomo;

    private LocalDateTime ultimaAtualizacaoPrecos;

    private LocalDate dataLancamento;

    private LocalDateTime dataCriacao = LocalDateTime.now();


}


============================================================
CAMINHO: src\main\java\br\com\lunix\model\entities\PrecoPlataforma.java
============================================================
package br.com.lunix.model.entities;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.io.Serial;
import java.io.Serializable;

/*
    Classe de suporte que recebe informações de sobre
    preços de um jogo em diversas lojas

    @Getter @Setter - Cria todos os getters e setters da classe.
    @NoArgsConstructor @AllArgsConstructor - Anotações que criam
    automaticamente os construtores pricipais da classe.
*/
@Getter @Setter
@AllArgsConstructor
@NoArgsConstructor
public class PrecoPlataforma implements Serializable {

    private String nomeLoja;

    private double precoAtual;

    private double precoBase;

    private int descontoPercentual;

    private String urlLoja;
}


============================================================
CAMINHO: src\main\java\br\com\lunix\model\entities\Usuario.java
============================================================
package br.com.lunix.model.entities;

import br.com.lunix.model.enums.Role;
import lombok.*;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.index.Indexed;
import org.springframework.data.mongodb.core.mapping.DBRef;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.LocalDateTime;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

/*
    Entidade do banco de dados que receberá os usuários
    da aplicação.

    Implementa a interface **UserDetails** para indicar
    que esta é a classe que será utilizada para referenciar
    login e cadastro na aplicação.

    @Document - Define a classe como uma entidade no MongoDB.
    @Getter @Setter - Cria todos os getters e setters da classe.

    @NoArgsConstructor @AllArgsConstructor - Anotações que criam
    automaticamente os construtores pricipais da classe.

    @EqualsAndHashCode - Cria automaticamente métodos equals e hashcode
    para comparar a igualdade lógica entre objetos.
*/
@Document(collection = "usuarios")
@Getter @Setter
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode
public class Usuario implements UserDetails {

    @Id
    private String id;

    private String nome;

    @Indexed(unique = true)
    private String email;

    private String senha;

    private Set<Role> roles = new HashSet<>();

    @DBRef
    private Empresa empresa;

    private boolean ativo = true;

    private LocalDateTime dataCriacao = LocalDateTime.now();

    // Método que define quais são as Roles que um usuário pode ter
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        /*
            Faz o stream dos cargos disponíveis e os mapeia a partir do nome
            para definir todos os cargos presentes na aplicação
        */

        return roles.stream()
                .map(role -> new SimpleGrantedAuthority(role.name()))
                .collect(Collectors.toList());
    }

    // Método que busca o usuário específico para login
    @Override
    public String getUsername() {
        return this.email;
    }

    // Método que busca a senah do usuário para realizar o login
    @Override
    public String getPassword() {
        return this.senha;
    }

    // Método que define se a conta está expirada ou não
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    // Método que define se a conta foi bloqueada ou não
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }

    // Método que indica se as credenciais do usuário expiraram
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }

    // Método que define se o usuário está habilitado
    @Override
    public boolean isEnabled() {
        return this.ativo;
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\model\enums\ClassificacaoIndicativa.java
============================================================
package br.com.lunix.model.enums;

import lombok.AllArgsConstructor;
import lombok.Getter;

/*
    Enum com dados de classificação indicativa para o cadastro
    dos jogos na aplicação.

    @param selo - Símbolo referente a classificação indicativa específica.
    @param descricao - Descrição do que significa aquele selo.
    @param corHex - Código Hex de cor para utilização simplificada no front-end
*/
@Getter
@AllArgsConstructor
public enum ClassificacaoIndicativa {
    LIVRE("L", "Livre para todos os públicos", "#008641"),
    DEZ("10", "Não recomendado para menores de 10 anos", "#00A5E3"),
    DOZE("12", "Não recomendado para menores de 12 anos", "#F8A503"),
    CATORZE("14", "Não recomendado para menores de 14 anos", "#E87A1E"),
    DEZESSEIS("16", "Não recomendado para menores de 16 anos", "#C42127"),
    DEZOITO("18", "Não recomendado para menores de 18 anos", "#231F20");

    private final String selo;
    private final String descricao;
    private final String corHex;
}


============================================================
CAMINHO: src\main\java\br\com\lunix\model\enums\Genero.java
============================================================
package br.com.lunix.model.enums;

/*
    Enum com todos os gêneros de jogos que podem ser
    utilizados na aplicação
*/
public enum Genero {
    ACAO,
    AVENTURA,
    RPG,
    ESTRATEGIA,
    SIMULACAO,
    SHOOTER,
    ESPORTES,
    CORRIDA,
    PUZZLE,
    PLATAFORMA,
    LUTA,
    SOULS_LIKE,
    METROIDVANIA,
    ROGUE_LIKE,
    SURVIVAL,
    BATTLE_ROYALE,
    TERROR,
    OUTROS
}


============================================================
CAMINHO: src\main\java\br\com\lunix\model\enums\Plataforma.java
============================================================
package br.com.lunix.model.enums;

/*
    Enum que traz diversas plataformas que podem ser atribuídas
    a jogos, em caso não se qualifique nos selecionados ele
    pode ser colocado como outro.
*/
public enum Plataforma {
    PC,
    PLAYSTATION_5,
    PLAYSTATION_4,
    XBOX_SERIES,
    XBOX_ONE,
    NINTENDO_SWITCH,
    MACOS,
    LINUX,
    ANDROID,
    IOS,
    NINTENDO_3DS,
    NINTENDO_DS,
    XBOX360,
    PLAYSTATION_1,
    PLAYSTATION_2,
    PLAYSTATION_3,
    OUTROS
}


============================================================
CAMINHO: src\main\java\br\com\lunix\model\enums\Role.java
============================================================
package br.com.lunix.model.enums;


/*
    Enum utilizado para definir as Roles(cargos) possíveis que um usuário pode ter
    na aplicação.

    ROLE_USER - Usuário comum que têm somente permissões de leitura(read) e de criação de
    avaliações para jogos.

    ROLE_ADMIN - ADMIN possuí permissão total a todos os sistemas na aplicação e áreas únicas para o mesmo.

    ROLE_DEV - Devs possuem permissões de usuários comuns e a capacidade de inserir, deletar e editar jogos
    que eles criaram, além de possuir áreas próprias para o mesmo.
*/
public enum Role {
    ROLE_USER,
    ROLE_ADMIN,
    ROLE_DEV
}


============================================================
CAMINHO: src\main\java\br\com\lunix\repository\AvaliacaoRepository.java
============================================================
package br.com.lunix.repository;

import br.com.lunix.model.entities.Avaliacao;
import br.com.lunix.model.entities.Jogo;
import br.com.lunix.model.entities.Usuario;
import org.springframework.data.mongodb.repository.MongoRepository;

import java.util.List;

public interface AvaliacaoRepository extends MongoRepository<Avaliacao, String> {

    // Método para encontrar todas as avaliações de um jogo
    List<Avaliacao> findAllByJogoOrderByDataCriacaoDesc(Jogo jogo);

    // Método para encontrar todas as avaliações feitas por um usuário
    List<Avaliacao> findAllByUsuarioOrderByDataCriacaoDesc(Usuario usuario);

    // Método para verificar se uma avaliação existe com um usuário e jogo específico
    boolean existsByUsuarioAndJogo(Usuario usuario, Jogo jogo);
}


============================================================
CAMINHO: src\main\java\br\com\lunix\repository\EmpresaRepository.java
============================================================
package br.com.lunix.repository;

import br.com.lunix.model.entities.Empresa;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.repository.MongoRepository;

import java.util.Optional;

public interface EmpresaRepository extends MongoRepository<Empresa, String> {

    // Método responsável por encontrar empresas pelo nome parcial
    Page<Empresa> findByNomeContainingIgnoreCase(String nome, Pageable pageable);

    // Método responsável por achar uma empresa pelo exato nome
    Optional<Empresa> findByNomeIgnoreCase(String nome);

    // Método responsável por encontrar uma empresa pelo país de origem dela
    Page<Empresa> findByPaisOrigemIgnoreCase(String paisOrigem, Pageable pageable);
}


============================================================
CAMINHO: src\main\java\br\com\lunix\repository\JogoRepository.java
============================================================
package br.com.lunix.repository;

import br.com.lunix.model.entities.Empresa;
import br.com.lunix.model.entities.Jogo;
import br.com.lunix.model.entities.Usuario;
import br.com.lunix.model.enums.ClassificacaoIndicativa;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.repository.MongoRepository;
import org.springframework.data.mongodb.repository.Query;

import java.util.List;

public interface JogoRepository extends MongoRepository<Jogo, String> {

    /*
        Procura jogos com o título **SEMELHANTE** ao inserido

        @param titulo - Título dos jogos a serem buscados

        return: Lista de jogos cujo o título contenha o que foi inserido
    */
    Page<Jogo> findByTituloContainingIgnoreCase(String titulo, Pageable pageable);

    /*
         Procura jogos a partir do gênero inserido

         @param genero - Genero dos jogos a serem buscados(Lista de gêneros presente no Enum Genero)

         return: Lista de jogos que contém o gênero inserido
    */
    Page<Jogo> findByGeneros(Genero genero, Pageable pageable);

    /*
        Procura todos os jogos pertencentes a uma empresa específica

        @param empresa - Empresa utilizada para realizar a pesquisa

        return: Lista de jogos da empresa inserida
    */
    Page<Jogo> findByEmpresa(Empresa empresa, Pageable pageable);

    /*
        Procura jogos desenvolvidos por um único DEV (ex: Toby fox)

        @param devAutonomo - Nome de usuário do dev do jogo

        return: Lista de jogos feitos por aquele DEV
    */
    Page<Jogo> findByDevAutonomo(Usuario devAutonomo, Pageable pageable);

    /*
        Busca os 10 jogos mais bem avaliados da aplicação

        return: Retorna uma lista com os 10 jogos com as maiores notas médias da aplicação
    */
    List<Jogo> findTop10ByOrderByNotaMediaDesc();

    /*
        Busca os 10 jogos recentemente inseridos

        return: Retorna uma lista com os 10 jogos que foram lançados
        recentemente.
    */
    List<Jogo> findTop10ByOrderByDataLancamentoDesc();

    /*
      Busca todos os jogos que contêm uma plataforma específica em sua lista.
      Essencial para a funcionalidade de filtro por plataforma.
    */
    Page<Jogo> findByPlataformas(Plataforma plataforma, Pageable pageable);

    // Encontra jogos que falharam na sincronização (lista de preços vazia)
    @Query("{ 'precos': { $exists: true, $size: 0 } }")
    Page<Jogo> findByPrecosIsEmpty(Pageable pageable);

    // Conta os jogos por genero
    long countByGeneros(Genero genero);

    // Conta os jogos pela plataforma
    long countByPlataformas(Plataforma plataforma);

    // Método para verificar se existe jogos com essa empresa
    boolean existsByEmpresa(Empresa empresa);
}


============================================================
CAMINHO: src\main\java\br\com\lunix\repository\UsuarioRepository.java
============================================================
package br.com.lunix.repository;

import br.com.lunix.model.entities.Empresa;
import br.com.lunix.model.entities.Usuario;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.mongodb.repository.MongoRepository;

import java.util.Optional;

public interface UsuarioRepository extends MongoRepository<Usuario, String> {

    /*
        Busca um usuário pelo email dele na aplicação

        @param email - Email a ser buscado no banco de dados

        return: Retorna um único usuário com email correspondente ao utilizado na busca
    */
    Optional<Usuario> findByEmail(String email);

    /*
        Busca usuários pelo nome dos mesmos.
        @param nome - Nome do usuário na aplicação.
    */
    Page<Usuario> findByNomeContainingIgnoreCase(String nome, Pageable pageable);

    // Método para verificar se um usuário existe pela empresa
    boolean existsByEmpresa(Empresa empresa);
}


============================================================
CAMINHO: src\main\java\br\com\lunix\scheduler\JogoPrecoScheduler.java
============================================================
package br.com.lunix.scheduler;

import br.com.lunix.services.jogo.JogoPrecoService;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
public class JogoPrecoScheduler {

    private static final Logger log = LoggerFactory.getLogger(JogoPrecoScheduler.class);

    private final JogoPrecoService precoService;

    /*
        Executa a atualização de preços automaticamente.
        Cron Pattern: Seg Min Hora Dia Mes DiaSemana
    */

    // Configurado para rodar todos os dias às 03:00 AM
    @Scheduled(cron = "0 0 3 * * *")
    public void agendarAtualizacaoDiaria() {
        log.info("SCHEDULER: Acordando para atualizar preços dos jogos...");
        precoService.enviarTodosParaFila();
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\services\dashboard\DashboardService.java
============================================================
package br.com.lunix.services.dashboard;

import br.com.lunix.dto.dashboard.DashboardJogoDto;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import br.com.lunix.repository.JogoRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashMap;
import java.util.Map;

// Service responsável por gerar dados de consulta em um Dashboard para ADMIN
@Service
@RequiredArgsConstructor
public class DashboardService {

    private final JogoRepository jogoRepository;

    @Transactional(readOnly = true)
    public DashboardJogoDto gerarDadosDashboard() {
        long totalJogos = jogoRepository.count();
        long semPreco = jogoRepository.findByPrecosIsEmpty(Pageable.unpaged()).getTotalElements();

        Map<String, Long> porGenero = new HashMap<>();
        for (Genero g : Genero.values()) {
            long count = jogoRepository.countByGeneros(g);
            if (count > 0) porGenero.put(g.name(), count);
        }

        Map<String, Long> porPlataforma = new HashMap<>();
        for (Plataforma p : Plataforma.values()) {
            long count = jogoRepository.countByPlataformas(p);
            if (count > 0) porPlataforma.put(p.name(), count);
        }

        return new DashboardJogoDto(totalJogos, semPreco, porGenero, porPlataforma);
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\services\empresa\EmpresaService.java
============================================================
package br.com.lunix.services.empresa;

import br.com.lunix.dto.empresa.EmpresaDetalhesDto;
import br.com.lunix.dto.empresa.EmpresaRequestDto;
import br.com.lunix.dto.empresa.EmpresaResponseDto;
import br.com.lunix.dto.empresa.EmpresaUpdateDto;
import br.com.lunix.dto.jogos.JogoResponseDto;
import br.com.lunix.exceptions.RegraDeNegocioException;
import br.com.lunix.exceptions.ResourceNotFoundException;
import br.com.lunix.mapper.EmpresaMapper;
import br.com.lunix.mapper.JogoMapper;
import br.com.lunix.model.entities.Empresa;
import br.com.lunix.repository.EmpresaRepository;
import br.com.lunix.repository.JogoRepository;
import br.com.lunix.repository.UsuarioRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class EmpresaService {

    private final EmpresaRepository repository;
    private final JogoRepository jogoRepository;
    private final UsuarioRepository usuarioRepository;

    private final EmpresaMapper mapper;
    private final JogoMapper jogoMapper;

    /*
        Cria uma nova empresa no sistema.
        Verifica duplicidade de nome antes de salvar.

        @param dto - Dados da nova empresa.
        return: Dados da empresa criada.
    */
    @Transactional
    public EmpresaResponseDto create(EmpresaRequestDto dto){
        if (repository.findByNomeIgnoreCase(dto.nome()).isPresent()) {
            throw new RegraDeNegocioException("Já existe uma empresa cadastrada com o nome: " + dto.nome());
        }

        Empresa entity = mapper.toEntity(dto);
        entity = repository.save(entity);

        return mapper.toResponseDto(entity);
    }

    /*
        Lista todas as empresas registradas com paginação.

        @param page - Número da página.
        @param size - Itens por página.
    */
    @Transactional(readOnly = true)
    public Page<EmpresaResponseDto> findAll(int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("nome").ascending());
        Page<Empresa> empresas = repository.findAll(pageable);

        return empresas.map(mapper::toResponseDto);
    }

    /*
        Busca empresas filtrando pelo país de origem.

        @param pais - Nome do país.
    */
    @Transactional(readOnly = true)
    public Page<EmpresaResponseDto> findByPais(String pais, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("nome").ascending());
        Page<Empresa> empresas = repository.findByPaisOrigemIgnoreCase(pais, pageable);

        return empresas.map(mapper::toResponseDto);
    }

    /*
        Busca empresas pelo nome das mesmas

        @param nome - Nome da empresa
    */
    @Transactional(readOnly = true)
    public Page<EmpresaResponseDto> findByNome(String nome, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("nome").ascending());
        Page<Empresa> empresas = repository.findByNomeContainingIgnoreCase(nome, pageable);

        return empresas.map(mapper::toResponseDto);
    }

    /*
        Busca os detalhes completos de uma empresa, INCLUINDO a lista de jogos dela.

        @param id - ID da empresa.
    */
    @Transactional(readOnly = true)
    public EmpresaDetalhesDto findById(String id) {
        Empresa empresa = repository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Empresa não encontrada com o ID: " + id));

        // Busca os jogos vinculados a essa empresa para popular o DTO
        List<JogoResponseDto> jogosDaEmpresa = jogoRepository.findByEmpresa(empresa, Pageable.unpaged())
                .stream()
                .map(jogoMapper::toResponseDto)
                .collect(Collectors.toList());

        return mapper.toDetalhesDto(empresa, jogosDaEmpresa);
    }

    /*
        Atualiza dados de uma empresa.
        Verifica se a mudança de nome não conflita com outra empresa existente.

        @param id - ID da empresa.
        @param dto - Novos dados.
    */
    @Transactional
    public EmpresaResponseDto update(String id, EmpresaUpdateDto dto) {
        Empresa empresa = repository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Empresa não encontrada com o ID: " + id));

        // Regra: Se o nome mudou, verifica se o novo nome já existe em OUTRA empresa
        if (!empresa.getNome().equalsIgnoreCase(dto.nome()) &&
                repository.findByNomeIgnoreCase(dto.nome()).isPresent()) {
            throw new RegraDeNegocioException("Já existe uma empresa cadastrada com o nome: " + dto.nome());
        }

        mapper.updateEntityFromDto(dto, empresa);
        empresa = repository.save(empresa);

        return mapper.toResponseDto(empresa);
    }

    /*
        Deleta uma empresa do sistema.

        @param id - ID da empresa.
    */
    @Transactional
    public void delete(String id) {
        // Buscamos a empresa primeiro para garantir que existe
        Empresa empresa = repository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Empresa não encontrada com ID: " + id));

        // Verifica se existe ALGUM jogo vinculado a esta empresa
        if (jogoRepository.existsByEmpresa(empresa)) {
            throw new RegraDeNegocioException("Não é possível deletar a empresa pois existem JOGOS vinculados a ela.");
        }

        // Verifica se existe ALGUM usuário vinculado a esta empresa
        if (usuarioRepository.existsByEmpresa(empresa)) {
            throw new RegraDeNegocioException("Não é possível deletar a empresa pois existem USUÁRIOS vinculados a ela.");
        }

        // Se passou pelas validações, deleta
        repository.delete(empresa);
    }
}

============================================================
CAMINHO: src\main\java\br\com\lunix\services\itad\ItadApiService.java
============================================================
package br.com.lunix.services.itad;

import br.com.lunix.dto.itad.ItadRecords.*;
import br.com.lunix.mapper.ItadMapper;
import br.com.lunix.model.entities.PrecoPlataforma;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/*
    Serviço utilizado para buscar preços de um jogo em diversas plataformas.

    Busca a partir do título, de onde é recuperado um id que será
    utilizado para as lojas e preços referentes ao jogo.
*/
@Service
public class ItadApiService {

    private static final Logger log = LoggerFactory.getLogger(ItadApiService.class);
    private final RestTemplate restTemplate;
    private final String apiKey;
    private final String apiBaseUrl;

    @Autowired
    private ItadMapper itadMapper;

    public ItadApiService(@Value("${itad.api.key}") String apiKey,
                          @Value("${itad.api.baseurl}") String apiBaseUrl,
                          RestTemplateBuilder builder) {
        this.apiKey = apiKey;
        this.apiBaseUrl = apiBaseUrl;
        this.restTemplate = builder.build();
    }

    /*
        Método principal que utiliza os outros dois para realizar a pesquisa dos jogos.

        @param tituloDoJogo: Titulo do jogo a ser buscado.

        @return: Retorna uma lista com todas as lojas e seus preços
        do jogo buscado. Em caso de erro devolve uma lista vazia.
    */
    public List<PrecoPlataforma> buscarPrecosParaJogo(String tituloDoJogo) {
        /*
            Primeiro chama o método findGameId para encontrar
            o identificador único do jogo na API.

            Após chama o método getPricesForId com o ID encontrado
            e devolve a lisca de precos.

            Em caso de erros ele sempre devolverá uma lista vazia.
        */

        try {
            // Chamada do método para encontrar o ID
            String gameId = findGameId(tituloDoJogo);

            // Verificação para saber se o ID foi encontrado
            if (gameId == null) {
                log.warn("Nenhum ID encontrado na API ITAD para o jogo: {}", tituloDoJogo);
                return Collections.emptyList();
            }
            log.info("ID encontrado para '{}': {}", tituloDoJogo, gameId);

            // Chama o método que gera a lista de lojas a partir do ID
            return getPricesForId(gameId);
        } catch (Exception e) {
            log.error("Erro geral ao buscar preços na ITAD para '{}': {}", tituloDoJogo, e.getMessage());
            return Collections.emptyList();
        }
    }

    /*
        Método que busca o ID de um jogo da API pelo título.

        @param titulo: Título do jogo a ser buscado.
        @return: Retorna um ID no formato de String.
    */
    private String findGameId(String titulo) {
        /*
            Utiliza o padrão de criação de Link com URI para se conectar
            com a API, então ele salva a resposta dada em um objeto
            ItadLookupResponseDto e filtra a resposta registrando o jogo
            e seu id respectivo.

            Caso não seja encontrado ele devolverá um null.
        */

        // Formatação para a chamada da API
        URI uri = UriComponentsBuilder.fromUriString(apiBaseUrl)
                .path("/games/lookup/v1")
                .queryParam("key", apiKey)
                .queryParam("title", titulo)
                .build().toUri();

        try {
            // Registra a resposta
            ItadLookupResponseDto response = restTemplate.getForObject(uri, ItadLookupResponseDto.class);

            // Faz a filtragem da resposta para transformar em DTO
            return Optional.ofNullable(response)
                    .filter(ItadLookupResponseDto::found)
                    .map(ItadLookupResponseDto::game)
                    .map(ItadGameLookupDto::id)
                    .orElse(null);

        } catch (HttpClientErrorException e) {
            log.error("Erro na API ITAD ao buscar ID para '{}': {} {}", titulo, e.getStatusCode(), e.getResponseBodyAsString());
            return null;
        }
    }

    /*
        Método responsável por buscar todos os preços de um jogo
        em diversas lojas a partir de um ID.

        @param gameId: ID do jogo escolhido vindo da API.

        @return: Devolve uma lista de PrecoPlataforma que contém as lojas
        e o preço referente aquela loja.
    */
    private List<PrecoPlataforma> getPricesForId(String gameId) {
        /*
            Faz uma requisição POST para a API enviando o ID por meio de
            URI, depois faz um mapeamento da resposta gerada para transformar
            a resposta em PrecoPlataforma.

            Em caso de erro devolve uma lista nula.
        */

        // Gera o link da requisição.
        URI uri = UriComponentsBuilder.fromUriString(apiBaseUrl)
                .path("/games/prices/v3")
                .queryParam("key", apiKey)
                .queryParam("country", "BR")
                .build().toUri();
        try {
            // Faz o corpo da requisição já que ele só aceita listas
            List<String> requestBody = List.of(gameId);

            // Faz a requisição e armazena no objeto ItadPriceResultDto
            ItadPriceResultDto[] response = restTemplate.postForObject(uri, requestBody, ItadPriceResultDto[].class);

            // Gera uma resposta com Optional para tratar nulos
            return Optional.ofNullable(response)
                    .filter(r -> r.length > 0)
                    .map(r -> r[0]) // Pegamos o primeiro (e único) resultado do array
                    .map(ItadPriceResultDto::deals) // Faz o mapeamento das lojas
                    .map(deals -> deals.stream()
                            .map(itadMapper::toPrecoPlataforma) // Transforma o objeto da resposta em PrecoPlataforma
                            .collect(Collectors.toList())) // Transforma a resposta em uma lista
                    .orElse(Collections.emptyList()); // Em caso de falha devolve uma lista nula

        } catch (HttpClientErrorException e) {
            log.error("Erro na API ITAD ao buscar preços para o ID '{}': {} {}", gameId, e.getStatusCode(), e.getResponseBodyAsString());
            return Collections.emptyList();
        } catch (Exception e) {
            log.error("Erro geral ao extrair resposta para o ID '{}': {}", gameId, e.getMessage(), e);
            return Collections.emptyList();
        }
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\services\jogo\JogoImportService.java
============================================================
package br.com.lunix.services.jogo;

import br.com.lunix.dto.jogos.JogoMapeadoDto;
import br.com.lunix.dto.rawg.RawgRecords;
import br.com.lunix.exceptions.ResourceNotFoundException;
import br.com.lunix.mapper.RawgMapper;
import br.com.lunix.services.rawg.RawgApiService;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;

/*
    Service responsável por importar dados da API do RAWG
    para facilitação no front-end.
*/
@Service
@RequiredArgsConstructor
public class JogoImportService {

    private final RawgApiService rawgApiService;
    private final RawgMapper rawgMapper;

    public JogoMapeadoDto importarDadosRawg(String titulo) {
        List<RawgRecords.RawgGameDto> resultados = rawgApiService.buscarJogos(titulo, 1);
        if (resultados.isEmpty()) {
            throw new ResourceNotFoundException("Nenhum jogo encontrado na RAWG com o título: " + titulo);
        }
        return rawgMapper.toJogoMapeado(resultados.get(0));
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\services\jogo\JogoPrecoService.java
============================================================
package br.com.lunix.services.jogo;

import br.com.lunix.exceptions.RegraDeNegocioException;
import br.com.lunix.exceptions.ResourceNotFoundException;
import br.com.lunix.model.entities.Jogo;
import br.com.lunix.model.entities.PrecoPlataforma;
import br.com.lunix.repository.JogoRepository;
import br.com.lunix.services.itad.ItadApiService;
import lombok.RequiredArgsConstructor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.List;

/*
    Service responsável por controlar a atualização de preços
    com a API do ITAD.
*/
@Service
@RequiredArgsConstructor
public class JogoPrecoService {

    private static final Logger log = LoggerFactory.getLogger(JogoPrecoService.class);

    private final JogoRepository jogoRepository;
    private final ItadApiService itadApiService;
    private final RabbitTemplate rabbitTemplate;

    private final JogoSecurityService securityService;

    @Value("${indiezone.rabbitmq.queue}")
    private String queueName;

    // Métodos de envio (Producer)

    public void enviarParaFila(String jogoId) {
        log.info("Enviando jogo {} para fila de preços.", jogoId);
        rabbitTemplate.convertAndSend(queueName, jogoId);
    }

    public void enviarTodosParaFila() {
        List<Jogo> todosJogos = jogoRepository.findAll();
        log.info("Disparando atualização em massa para {} jogos.", todosJogos.size());
        todosJogos.forEach(jogo -> rabbitTemplate.convertAndSend(queueName, jogo.getId()));
    }

    public void solicitarAtualizacaoManual(String jogoId) {
        if (!jogoRepository.existsById(jogoId)) {
            throw new ResourceNotFoundException("Jogo não encontrado.");
        }
        enviarParaFila(jogoId);
    }

    @CacheEvict(value = "jogo-detalhes", allEntries = true)
    public void solicitarAtualizacaoGlobalAdmin() {
        var usuario = securityService.getUsuarioLogado();
        // Validação de segurança simplificada
        if (usuario.getRoles().stream().noneMatch(r -> r.name().equals("ROLE_ADMIN"))) {
            throw new RegraDeNegocioException("Apenas admin pode disparar atualização global.");
        }
        enviarTodosParaFila();
    }

    // Métodos de processamento (consumidor)
    @Transactional
    @CacheEvict(value = "jogos-detalhes", key = "#jogoId")
    public boolean processarAtualizacaoLogica(String jogoId) {
        return jogoRepository.findById(jogoId).map(jogo -> {
            log.info("Processando atualização de preço para: {}", jogo.getTitulo());

            List<PrecoPlataforma> novosPrecos = itadApiService.buscarPrecosParaJogo(jogo.getTitulo());

            if (!novosPrecos.isEmpty()) {
                jogo.setPrecos(novosPrecos);
                jogo.setUltimaAtualizacaoPrecos(LocalDateTime.now());
                jogoRepository.save(jogo);
                return true;
            }
            return false;
        }).orElse(false);
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\services\jogo\JogoSecurityService.java
============================================================
package br.com.lunix.services.jogo;

import br.com.lunix.dto.jogos.JogoAdminRequestDto;
import br.com.lunix.exceptions.RegraDeNegocioException;
import br.com.lunix.exceptions.ResourceNotFoundException;
import br.com.lunix.model.entities.Empresa;
import br.com.lunix.model.entities.Jogo;
import br.com.lunix.model.entities.Usuario;
import br.com.lunix.model.enums.Role;
import br.com.lunix.repository.EmpresaRepository;
import br.com.lunix.repository.UsuarioRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

/*
    Classe de serviço para gerenciar as permissões,
    autenticações e vínculos de dono.
*/
@Service
@RequiredArgsConstructor
public class JogoSecurityService {

    private final UsuarioRepository usuarioRepository;
    private final EmpresaRepository empresaRepository;

    /*
        Recupera o objeto Usuario completo do contexto de segurança (SecurityContextHolder).
    */
    public Usuario getUsuarioLogado() {
        Object principal = SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        if (principal instanceof Usuario) {
            return (Usuario) principal;
        }
        // Fallback: caso o principal seja apenas o email (String), busca no banco
        String email = (String) principal;
        return usuarioRepository.findByEmail(email)
                .orElseThrow(() -> new ResourceNotFoundException("Usuário logado não encontrado no banco."));
    }

    /*
        Valida se o usuário logado é dono do jogo (Autônomo ou Empresa) ou Admin.
        Lança RegraDeNegocioException se não tiver permissão.
    */
    public void validarPermissaoEdicao(Jogo jogo) {
        Usuario usuario = getUsuarioLogado();

        // Admin tem passe livre
        if (usuario.getRoles().contains(Role.ROLE_ADMIN)) return;

        // Verifica se é o Dev Autônomo dono do jogo
        boolean isDonoAutonomo = jogo.getDevAutonomo() != null &&
                jogo.getDevAutonomo().getId().equals(usuario.getId());

        // Verifica se a empresa do usuário é a mesma do jogo
        boolean isDonoEmpresa = jogo.getEmpresa() != null &&
                usuario.getEmpresa() != null &&
                jogo.getEmpresa().getId().equals(usuario.getEmpresa().getId());

        if (!isDonoAutonomo && !isDonoEmpresa) {
            throw new RegraDeNegocioException("Você não tem permissão para alterar este jogo.");
        }
    }

    // Método responsável por definir quem está cadastrando o jogo
    public void definirDonoDoJogo(Jogo jogo, JogoAdminRequestDto request) {
        Usuario usuario = getUsuarioLogado();

        if (usuario.getRoles().contains(Role.ROLE_ADMIN)) {
            vincularComoAdmin(jogo, request.empresaIdExistente(), request.devId());
        } else {
            vincularComoDev(jogo, usuario);
        }
    }

    // Lógica para quando um ADMIN cadastra um jogo: ele deve especificar quem é o dono.
    private void vincularComoAdmin(Jogo jogo, String empresaId, String devId){
        if (empresaId != null && !empresaId.isBlank()) {
            Empresa empresa = empresaRepository.findById(empresaId)
                    .orElseThrow(() -> new ResourceNotFoundException("Empresa não encontrada: " + empresaId));
            jogo.setEmpresa(empresa);

        } else if (devId != null && !devId.isBlank()) {
            Usuario dev = usuarioRepository.findById(devId)
                    .orElseThrow(() -> new ResourceNotFoundException("Dev não encontrado: " + devId));
            jogo.setDevAutonomo(dev);

        } else {
            throw new RegraDeNegocioException("Admin deve informar ID da Empresa para vincular o jogo.");
        }
    }

    // Lógica para quando um DEV cadastra: vincula automaticamente ao seu perfil ou empresa.
    private void vincularComoDev(Jogo jogo, Usuario devLogado) {
        if (devLogado.getEmpresa() != null) {
            jogo.setEmpresa(devLogado.getEmpresa());
        } else {
            jogo.setDevAutonomo(devLogado);
        }
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\services\jogo\JogoService.java
============================================================
package br.com.lunix.services.jogo;

import br.com.lunix.dto.avaliacao.AvaliacaoResponseDto;
import br.com.lunix.dto.jogos.*;
import br.com.lunix.exceptions.ResourceNotFoundException;
import br.com.lunix.mapper.AvaliacaoMapper;
import br.com.lunix.mapper.JogoMapper;
import br.com.lunix.model.entities.Avaliacao;
import br.com.lunix.model.entities.Empresa;
import br.com.lunix.model.entities.Jogo;
import br.com.lunix.model.entities.Usuario;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import br.com.lunix.model.enums.Role;
import br.com.lunix.repository.AvaliacaoRepository;
import br.com.lunix.repository.EmpresaRepository;
import br.com.lunix.repository.JogoRepository;
import br.com.lunix.repository.UsuarioRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.cache.annotation.Caching;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/*
    Service responsável por orquestração das atividades de jogos
    da aplicação
*/
@Service
@RequiredArgsConstructor
public class JogoService {

    private final JogoRepository jogoRepository;
    private final AvaliacaoRepository avaliacaoRepository;
    private final EmpresaRepository empresaRepository;
    private final UsuarioRepository usuarioRepository;

    private final JogoMapper jogoMapper;
    private final AvaliacaoMapper avaliacaoMapper;

    private final JogoSecurityService securityService;
    private final JogoPrecoService precoService;

    /*
        Método responsável por cadastrar um novo jogo na plataforma.

        @param requestAdmin - DTO contendo os dados do jogo e possíveis vínculos de empresa/dev.
        return: Retorna o DTO do jogo recém-criado.
    */
    @Transactional
    @Caching(evict = {
            @CacheEvict(value = "jogos-top10-nota", allEntries = true),
            @CacheEvict(value = "jogos-top10-recentes", allEntries = true)
    })
    public JogoResponseDto cadastrar(JogoAdminRequestDto requestAdmin) {
        Jogo jogo = jogoMapper.toEntity(requestAdmin.jogoData());

        // Delega a lógica de permissão/dono
        securityService.definirDonoDoJogo(jogo, requestAdmin);

        jogo = jogoRepository.save(jogo);

        // Delega a integração de preço
        precoService.enviarParaFila(jogo.getId());

        return jogoMapper.toResponseDto(jogo);
    }

    /*
        Atualiza dados cadastrais de um jogo.
        Valida se o usuário tem permissão sobre aquele jogo específico.
        Limpa caches relacionados para garantir consistência dos dados.

        @param id - ID do jogo.
        @param dto - Novos dados.
    */
    @Transactional
    @Caching(evict = {
            @CacheEvict(value = "jogos-detalhes", key = "#id"),
            @CacheEvict(value = "jogos-top10-nota", allEntries = true),
            @CacheEvict(value = "jogos-top10-recentes", allEntries = true)
    })
    public JogoResponseDto atualizar(String id, JogoUpdateDto dto) {
        Jogo jogo = buscarPorId(id);

        // Validação delegada
        securityService.validarPermissaoEdicao(jogo);

        jogoMapper.updateEntityFromDto(dto, jogo);
        jogo = jogoRepository.save(jogo);

        return jogoMapper.toResponseDto(jogo);
    }

    /*
        Atualiza apenas a lista de gêneros de um jogo (PATCH).

        @param id - ID do jogo.
        @param dto - Lista nova de gêneros.
    */
    @Transactional
    @Caching(evict = {
            @CacheEvict(value = "jogos-detalhes", key = "#id"),
            @CacheEvict(value = "jogos-top10-nota", allEntries = true),
            @CacheEvict(value = "jogos-top10-recentes", allEntries = true)
    })
    public void patchGeneros(String id, JogoGenresPatchDto dto) {
        Jogo jogo = buscarPorId(id);
        securityService.validarPermissaoEdicao(jogo);

        jogoMapper.updateGeneros(dto, jogo);
        jogoRepository.save(jogo);
    }


    /*
        Deleta um jogo do sistema.
        Valida permissões e limpa todos os caches afetados.

        @param id - ID do jogo a ser deletado.
    */
    @Transactional
    @Caching(evict = {
            @CacheEvict(value = "jogos-detalhes", key = "#id"),
            @CacheEvict(value = "jogos-top10-nota", allEntries = true),
            @CacheEvict(value = "jogos-top10-recentes", allEntries = true)
    })
    public void deletar(String id) {
        Jogo jogo = buscarPorId(id);
        securityService.validarPermissaoEdicao(jogo);
        jogoRepository.delete(jogo);
    }

    // --- Consultas (Read Only) ---

    @Transactional(readOnly = true)
    @Cacheable(value = "jogos-detalhes", key = "#id")
    public JogoDetalhesDto buscarDetalhesPorId(String id) {
        Jogo jogo = buscarPorId(id);
        List<Avaliacao> todasAvaliacoes = avaliacaoRepository.findAllByJogoOrderByDataCriacaoDesc(jogo);

        return jogoMapper.toDetalhesDto(jogo,
                mapReviewsByRole(todasAvaliacoes, Role.ROLE_ADMIN),
                mapReviewsByRole(todasAvaliacoes, Role.ROLE_DEV),
                mapReviewsByRole(todasAvaliacoes, Role.ROLE_USER));
    }

    @Transactional(readOnly = true)
    public Page<JogoResponseDto> listarTodos(int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("dataLancamento").descending());
        return jogoRepository.findAll(pageable).map(jogoMapper::toResponseDto);
    }

    // ... buscarPorTitulo, buscarPorGenero, buscarPorPlataforma (Mantém iguais) ...

    /*
        Realiza a busca de jogos pelo título (Search Bar).
        A busca é parcial (containing) e ignora maiúsculas/minúsculas.

        @param titulo - Termo a ser pesquisado.
        @param page - Número da página.
        @param size - Quantidade de itens por página.
        return: Página com os jogos que correspondem ao termo pesquisado.
    */
    @Transactional(readOnly = true)
    public Page<JogoResponseDto> buscarPorTitulo(String titulo, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("titulo").ascending());
        return jogoRepository.findByTituloContainingIgnoreCase(titulo, pageable).map(jogoMapper::toResponseDto);
    }

    /*
        Filtra os jogos por um Gênero específico (ex: RPG, ACAO).

        @param genero - Enum do gênero desejado.
        @param page - Número da página.
        @param size - Quantidade de itens por página.
        return: Página com os jogos do gênero selecionado.
    */
    @Transactional(readOnly = true)
    public Page<JogoResponseDto> buscarPorGenero(Genero genero, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("dataLancamento").descending());
        return jogoRepository.findByGeneros(genero, pageable).map(jogoMapper::toResponseDto);
    }

    /*
        Filtra os jogos por Plataforma (ex: PC, PS5, SWITCH).

        @param plataforma - Enum da plataforma desejada.
        @param page - Número da página.
        @param size - Quantidade de itens por página.
        return: Página com os jogos disponíveis na plataforma.
    */
    @Transactional(readOnly = true)
    public Page<JogoResponseDto> buscarPorPlataforma(Plataforma plataforma, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("dataLancamento").descending());
        return jogoRepository.findByPlataformas(plataforma, pageable).map(jogoMapper::toResponseDto);
    }

    @Transactional(readOnly = true)
    public Page<JogoResponseDto> buscarPorEmpresa(String empresaId, int page, int size) {
        Empresa empresa = empresaRepository.findById(empresaId)
                .orElseThrow(() -> new ResourceNotFoundException("Empresa não encontrada."));
        Pageable pageable = PageRequest.of(page, size, Sort.by("dataLancamento").descending());
        return jogoRepository.findByEmpresa(empresa, pageable).map(jogoMapper::toResponseDto);
    }

    @Transactional(readOnly = true)
    public Page<JogoResponseDto> buscarPorDev(String devId, int page, int size) {
        Usuario dev = usuarioRepository.findById(devId)
                .orElseThrow(() -> new ResourceNotFoundException("Dev não encontrado."));
        Pageable pageable = PageRequest.of(page, size, Sort.by("dataLancamento").descending());
        return jogoRepository.findByDevAutonomo(dev, pageable).map(jogoMapper::toResponseDto);
    }

    @Transactional(readOnly = true)
    public Page<JogoResponseDto> listarMeusJogos(int page, int size) {
        Usuario usuario = securityService.getUsuarioLogado();
        Pageable pageable = PageRequest.of(page, size, Sort.by("titulo").ascending());

        if (usuario.getRoles().contains(Role.ROLE_ADMIN)) {
            return jogoRepository.findAll(pageable).map(jogoMapper::toResponseDto);
        }
        if (usuario.getEmpresa() != null) {
            return jogoRepository.findByEmpresa(usuario.getEmpresa(), pageable).map(jogoMapper::toResponseDto);
        } else {
            return jogoRepository.findByDevAutonomo(usuario, pageable).map(jogoMapper::toResponseDto);
        }
    }

    /*
        Busca os 10 jogos com melhor nota média.
        Resultado é armazenado em cache para performance da Home Page.
    */
    @Cacheable(value = "jogos-top10-nota")
    public List<JogoResponseDto> buscarTop10MelhoresAvaliados() {
        return jogoRepository.findTop10ByOrderByNotaMediaDesc().stream().map(jogoMapper::toResponseDto).toList();
    }

    /*
        Busca os 10 jogos lançados mais recentemente.
        Resultado é armazenado em cache.
    */
    @Cacheable(value = "jogos-top10-recentes")
    public List<JogoResponseDto> buscarTop10Lancamentos() {
        return jogoRepository.findTop10ByOrderByDataLancamentoDesc().stream().map(jogoMapper::toResponseDto).toList();
    }


    private Jogo buscarPorId(String id) {
        return jogoRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Jogo não encontrado. ID: " + id));
    }

    private List<AvaliacaoResponseDto> mapReviewsByRole(List<Avaliacao> avaliacoes, Role role) {
        return avaliacoes.stream()
                .filter(av -> av.getUsuario().getRoles().contains(role))
                .map(avaliacaoMapper::toResponseDto)
                .collect(Collectors.toList());
    }
}

============================================================
CAMINHO: src\main\java\br\com\lunix\services\rawg\RawgApiService.java
============================================================
package br.com.lunix.services.rawg;

import br.com.lunix.dto.rawg.RawgRecords.RawgApiResponseDto;
import br.com.lunix.dto.rawg.RawgRecords.RawgGameDto;
import br.com.lunix.dto.rawg.RawgRecords.RawgGenreDto;
import br.com.lunix.exceptions.JogoNaoIndieException;
import org.slf4j.LoggerFactory;
import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;

import java.net.URI;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;


/*
*   Serviço para buscar jogos utilizando a API do Rawg.Io
*
*   Busca jogos a partir do título do mesmo e devolve todas as informações necessárias,
*   é utilizado para facilitar a inserção de jogos na plataforma por meio do formulário
*/
@Service
public class RawgApiService {

    // Logger para a aplicação criar logs personalizados para o serviço, permitindo melhor depuração
    private static final Logger log = LoggerFactory.getLogger(RawgApiService.class);

    private RestTemplate restTemplate;
    private final String apiKey;
    private final String apiBaseUrl;

    // Construtor já passa o valor que o parâmetro vai utilizar
    public RawgApiService(@Value("${rawg.api.key}") String apiKey,
                          @Value("${rawg.api.baseurl}") String apiBaseUrl,
                          RestTemplateBuilder builder) {
        this.apiKey = apiKey;
        this.apiBaseUrl = apiBaseUrl;
        this.restTemplate = builder.build();
    }

    /*
    *   Método principal para buscar os jogos no endpoint search
    *
    *   @param termoBuca - Título do jogo a ser procurado
    *   @param limite - Quantidade de jogos limite que deve encontrar
    */
    public List<RawgGameDto> buscarJogos(String termoBusca, int limite) {
        log.info("Buscando jogos na RAWG com o termo '{}'", termoBusca);

        // Construindo a String de conexão com a API
        URI uri = UriComponentsBuilder.fromUriString(apiBaseUrl) // Utilizando com uri por ser uma forma segura de se criar a url
                .path("/api/games")
                .queryParam("key", apiKey)
                .queryParam("search", termoBusca)
                .queryParam("page_size", limite)
                .build()
                .toUri();

        try {
            // Pega a resposta encontrada e transforma no DTO de resposta da Rawg
            RawgApiResponseDto response = restTemplate.getForObject(uri, RawgApiResponseDto.class);

            if (response != null && response.results() != null) {
                // Pega a resposta encontrada e verifica se é um jogo indie
                List<RawgGameDto> jogosIndies = response.results().stream()
                        .filter(this::isIndie)
                        .collect(Collectors.toList());

                if (jogosIndies.isEmpty()) {
                    log.warn("O jogo '{}' foi encontrado na RAWG, mas filtrado pois não é INDIE.", termoBusca);
                    throw new JogoNaoIndieException("O jogo '" + termoBusca + "' foi encontrado, mas não é classificado como INDIE.");
                }


                return jogosIndies;
            }
        } catch (JogoNaoIndieException e){
            throw e;
        } catch (HttpClientErrorException e) {
            log.error("Erro na chamada para a API da RAWG: {} - {}", e.getStatusCode(), e.getResponseBodyAsString());
        } catch (Exception e) {
            log.error("Ocorreu um erro inesperado ao buscar jogos na RAWG", e);
        }

        // Caso não encontre jogos devolve um aviso e uma lista vazia
        log.warn("Nenhum resultado encontrado ou erro na API para a busca: '{}'", termoBusca);
        return Collections.emptyList();
    }

    /*
        Método auxiliar para verificar se o jogo puxado da API é Indie

        @param game: Jogo específico que é pesquisado
        @return: retorna true se o jogo for indie, se for false a api deve retornar nada
    */
    private boolean isIndie(RawgGameDto game) {
        if (game.genres() == null || game.genres().isEmpty()){
            return false;
        }

        for (RawgGenreDto genre : game.genres()) {
            if ("indie".equalsIgnoreCase(genre.slug()) || "indie".equalsIgnoreCase(genre.name())) {
                return true;
            }
        }
        return false;
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\services\usuario\TokenService.java
============================================================
package br.com.lunix.services.usuario;

import br.com.lunix.model.entities.Usuario;
import br.com.lunix.model.enums.Role;
import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTCreationException;
import com.auth0.jwt.exceptions.JWTVerificationException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class TokenService {

    @Value("${api.security.token.secret}")
    private String secret;

    private static final String ISSUER = "lunix-api";

    /*
        Método para gerar um token JWT para um usuário
        auntenticado

        @param usuario: Usuário a ser autenticado
        @return: Token JWT com as informações pertinentes ao usuário
    */
    public String generateToken(Usuario usuario) {
        try {
            Algorithm algorithm = Algorithm.HMAC256(secret);

            List<String> roles = usuario.getRoles().stream()
                    .map(Role::name)
                    .collect(Collectors.toList());

            return JWT.create()
                    .withIssuer(ISSUER)
                    .withSubject(usuario.getEmail())
                    .withClaim("role", roles)
                    .withClaim("id", usuario.getId())
                    .withExpiresAt(genExpirationDate())
                    .sign(algorithm);
        } catch (JWTCreationException e){
            throw new RuntimeException("Erro ao gerar o token JWT", e);
        }
    }

    public String validateToken(String token) {
        try {
            Algorithm algorithm = Algorithm.HMAC256(secret);

            return JWT.require(algorithm)
                    .withIssuer(ISSUER)
                    .build()
                    .verify(token)
                    .getSubject();
        } catch (JWTVerificationException exception) {
            return "";
        }
    }

    /*
        Método de geração de data de expiração

        @return: Retorna um LocalDateTime com o tempo para o token expirar
    */
    private Instant genExpirationDate() {
        return LocalDateTime.now().plusHours(2).toInstant(ZoneOffset.of("-03:00"));
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\services\usuario\UsuarioService.java
============================================================
package br.com.lunix.services.usuario;

import br.com.lunix.dto.usuario.*;
import br.com.lunix.exceptions.RegraDeNegocioException;
import br.com.lunix.exceptions.ResourceNotFoundException;
import br.com.lunix.mapper.UsuarioMapper;
import br.com.lunix.model.entities.Empresa;
import br.com.lunix.model.entities.Usuario;
import br.com.lunix.repository.EmpresaRepository;
import br.com.lunix.repository.UsuarioRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class UsuarioService {

    private final UsuarioRepository repository;
    private final EmpresaRepository empresaRepository;

    private final UsuarioMapper mapper;
    private final TokenService tokenService;
    private final AuthenticationManager authenticationManager;
    private final PasswordEncoder passwordEncoder;

    /*
        Realiza o login do usuário na aplicação e devolve um Token JWT
        @param dto - Entrada de dados para o login
    */
    public TokenResponseDto login(UsuarioLoginDto dto) {

        // Primeiro cria um token nativo do spring
        var usernamePassword = new UsernamePasswordAuthenticationToken(dto.email(), dto.senha());

        // Manager chama o UserDetailsServiceImpl
        Authentication auth = this.authenticationManager.authenticate(usernamePassword);

        // Gera o token JWT
        var token = tokenService.generateToken((Usuario) auth.getPrincipal());

        return new TokenResponseDto(token);
    }

    /*
        Registra usuários na aplicação com criptografiade senha
        @param dto - Dados de entrada do usuário para o registro
    */
    @Transactional
    public UsuarioProfileDto registrar(UsuarioRegistroDto dto) {

        // Validando se o email é único
        if (repository.findByEmail(dto.email()).isPresent()) {
            throw new RegraDeNegocioException("Este e-mail já está cadastrado.");
        }

        // Transformando o dto em entidade
        Usuario usuario = mapper.toEntity(dto);

        if (dto.idEmpresa() != null && !dto.idEmpresa().isEmpty()) {
            Empresa empresa = empresaRepository.findById(dto.idEmpresa())
                    .orElseThrow(() -> new ResourceNotFoundException("Empresa não encontrada com o id"));

            usuario.setEmpresa(empresa);

        }

        // Criptografando a senha do usuário
        usuario.setSenha(passwordEncoder.encode(dto.senha()));

        usuario = repository.save(usuario);

        return mapper.toProfileDto(usuario);
    }

    /*
        Lista todos os usuários da aplicação de forma paginada
        @param page - Quantidade de páginas a serem devolvidas
        @param size - Tamanho das páginas
    */
    @Transactional(readOnly = true)
    public Page<UsuarioAdminListDto> listarTodos(int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("nome").ascending());
        Page<Usuario> usuarios = repository.findAll(pageable);

        return usuarios.map(mapper::toAdminListDto);
    }

    /*
        Busca usuários por pelo nome parcial com paginação
        @param nome - Nome a ser pesquisados
        @param page - Quantidade de páginas a serem devolvidas
        @param size - Tamanho das páginas
    */
    @Transactional(readOnly = true)
    public Page<UsuarioAdminListDto> buscarPorNome(String nome, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("nome").ascending());

        Page<Usuario> usuarios = repository.findByNomeContainingIgnoreCase(nome, pageable);

        return usuarios.map(mapper::toAdminListDto);
    }

    /*
        Busca um usuário pelo id do mesmo
        @param id - ID do usuário a ser buscado
    */
    @Transactional(readOnly = true)
    public UsuarioProfileDto buscarPorId(String id) {
        Usuario usuario = repository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Usuário não encontrado. ID: " + id));

        return mapper.toProfileDto(usuario);
    }

    /*
        Atualiza os dados de um usuário
        @param id - ID do usuário a ser atualizado
        @param dto - Novos dados para atualizar
    */
    @Transactional
    public UsuarioAdminListDto atualizar(String id,UsuarioUpdateDto dto) {
        Usuario usuario = repository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Usuário não encontrado. ID: " + id));

        mapper.updateEntityFromDto(dto, usuario);

        // Lógica manual para vincular Empresa (se o ID for passado)
        if (dto.idEmpresa() != null && !dto.idEmpresa().isBlank()) {
            Empresa empresa = empresaRepository.findById(dto.idEmpresa())
                    .orElseThrow(() -> new ResourceNotFoundException("Empresa não encontrada. ID: " + dto.idEmpresa()));
            usuario.setEmpresa(empresa);
        } else {
            if (dto.idEmpresa() != null && dto.idEmpresa().isEmpty()) {
                usuario.setEmpresa(null);
            }
        }

        usuario = repository.save(usuario);
        return mapper.toAdminListDto(usuario);
    }

    /*
        Atualiza apenas as roles de um usuário
        @param id - ID do usuário a ter as roles atualizadas
        @param dto - Roles a serem atualizadas
    */
    @Transactional
    public UsuarioAdminListDto atualizarRoles(String id, UsuarioRolePatchDto dto) {
        Usuario usuario = repository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Usuário não encontrado. ID: " + id));

        usuario.setRoles(dto.roles());

        usuario = repository.save(usuario);

        return mapper.toAdminListDto(usuario);
    }

    /*
        Realiza uma exclusão lógica
        Usuário não é removido do banco, apenas desativado

        @param id - ID do usuário a ser desativado
    */
    @Transactional
    public void desativar(String id) {
        Usuario usuario = repository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Usuário não encontrado. ID: " + id));

        usuario.setAtivo(false);
        repository.save(usuario);
    }
}


============================================================
CAMINHO: src\main\java\br\com\lunix\util\ApiDataExplorer.java
============================================================
package br.com.lunix.util;

import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.web.client.RestTemplate;
import java.util.List;

/**
 * Ferramenta utilitária para explorar e listar todos os dados mestres da API da RAWG.
 * Execute o método main() para obter uma lista completa de todos os gêneros.
 * Isso ajuda a construir mappers completos e robustos.
 */
public class ApiDataExplorer {

    private static final String API_KEY = "SUA-CHAVE-API";
    private static final String BASE_URL = "https://api.rawg.io/api";
    private static final RestTemplate restTemplate = new RestTemplate();
    private static final ObjectMapper objectMapper = new ObjectMapper();

    // DTOs locais para esta ferramenta
    @JsonIgnoreProperties(ignoreUnknown = true)
    private record MasterDataDto(String slug, String name) {}

    @JsonIgnoreProperties(ignoreUnknown = true)
    private record ApiResponse(String next, List<MasterDataDto> results) {}

    public static void main(String[] args) throws JsonProcessingException {
        System.out.println("--- Buscando todos os Gêneros da RAWG ---");
        fetchAll("genres");

        System.out.println("===================================================================");

         System.out.println("\n--- Buscando todas as Plataformas da RAWG ---");
         fetchAll("platforms");
    }

    private static void fetchAll(String resource) throws JsonProcessingException {
        String nextUrl = BASE_URL + "/" + resource + "?key=" + API_KEY;

        while (nextUrl != null) {
            String jsonResponse = restTemplate.getForObject(nextUrl, String.class);
            ApiResponse response = objectMapper.readValue(jsonResponse, ApiResponse.class);

            for (MasterDataDto item : response.results()) {
                System.out.printf("Slug: %-30s | Name: %s\n", item.slug(), item.name());
            }

            nextUrl = response.next();
        }
    }
}

============================================================
CAMINHO: src\main\resources\application.properties
============================================================
spring.application.name=lunix

server.port=8081
server.servlet.context-path=/lunix

spring.data.mongodb.uri=mongodb://localhost:27017/test_db

# SWAGGER (Caminho da documentacao)
# Aceda em: http://localhost:8081/lunix/swagger-ui/index.html
springdoc.api-docs.path=/api-docs
springdoc.swagger-ui.path=/swagger-ui.html

# ACTUATOR
management.endpoints.web.exposure.include=health,info

# Chaves de API Externas
rawg.api.baseurl=https://api.rawg.io
rawg.api.key=${RAWG_API_KEY}

itad.api.baseurl=https://api.isthereanydeal.com
itad.api.key=${ITAD_API_KEY}

# JWT (Seguranca)
api.security.token.secret=${JWT_SECRET:minha-chave-secreta-super-segura}

# Configuracao das migrations com mongock
mongock.enabled=true
mongock.migration-scan-package=br.com.lunix.config.migrations
mongock.change-logs-collection-name=db_changelog
mongock.lock-collection-name=db_lock

# REDIS
spring.data.redis.host=${REDIS_HOST:localhost}
spring.data.redis.port=${REDIS_PORT:6379}
spring.data.redis.password=${REDIS_PASSWORD:}
spring.data.redis.username=${REDIS_USERNAME:}
spring.data.redis.timeout=5000

# RABBITMQ (Mensageria)
# Configuracao para o CloudAMQP
spring.rabbitmq.addresses=${RABBIT_ADD}
indiezone.rabbitmq.queue=indiezone.prices

# Rate Limiting
spring.rabbitmq.listener.simple.prefetch=1
spring.rabbitmq.listener.simple.retry.enabled=true

============================================================
CAMINHO: src\test\java\br\com\lunix\dto\JogoRequestDtoTest.java
============================================================
package br.com.lunix.dto;

import br.com.lunix.dto.jogos.JogoRequestDto;
import br.com.lunix.model.enums.ClassificacaoIndicativa;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.ValidatorFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import jakarta.validation.Validator;
import org.springframework.test.context.TestPropertySource;

import java.time.LocalDate;
import java.util.List;
import java.util.Set;

import static org.assertj.core.api.Assertions.assertThat;

/*
    Classe de teste para validar as anotações
    de validação da classe do DTO de jogo.
*/
public class JogoRequestDtoTest {

    @Autowired
    private Validator validator;

    @BeforeEach
    void setUp() {
        // Inicializa o validador padrão do Hibernate/Jakarta
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        this.validator = factory.getValidator();
    }

    /*
        Valida se o jogo está com a data no passado e se
        não há violações.
    */
    @Test
    public void quandoDtoEValidoComDataNoPassadoNaoDeveHaverViolacoes() {
        // Cria um exemplo de dto
        var dto = new JogoRequestDto(
                "Jogo Válido", "Descrição OK", null,
                LocalDate.now().minusYears(1),
                ClassificacaoIndicativa.LIVRE,
                List.of(Genero.AVENTURA),
                List.of(Plataforma.PC)
        );

        // Aplica o validador no dto de exemplo
        Set<ConstraintViolation<JogoRequestDto>> violations = validator.validate(dto);

        // Garante que não há violações
        assertThat(violations).isEmpty();
    }

    /*
        Teste para garantir que não há violações ao inserir
        um jogo com a data atual.
    */
    @Test
    public void quandoDtoEValidoComDataNoPresenteNaoDeveHaverViolacoes() {
        // Cria um exemplo de dto
        var dto = new JogoRequestDto(
                "Jogo Válido", "Descrição OK", null,
                LocalDate.now().minusYears(1),
                ClassificacaoIndicativa.LIVRE,
                List.of(Genero.AVENTURA),
                List.of(Plataforma.PC)
        );

        // Aplica o validador
        Set<ConstraintViolation<JogoRequestDto>> violations = validator.validate(dto);

        // Garante que não há violações
        assertThat(violations).isEmpty();
    }

    /*
        Teste para garantir que ao inserir um jogo com
        data no futuro ele tenha uma violação.
    */
    @Test
    public void quandoDataDeLancamentoENoFuturoDeveHaverViolacao() {
        var dto = new JogoRequestDto(
                "Jogo Inválido", "Descrição OK", null,
                LocalDate.now().plusDays(1), // Data no futuro
                ClassificacaoIndicativa.LIVRE,
                List.of(Genero.AVENTURA),
                List.of(Plataforma.PC)
        );

        Set<ConstraintViolation<JogoRequestDto>> violations = validator.validate(dto);

        // Garante que há exatamente uma violação
        assertThat(violations).hasSize(1);
        ConstraintViolation<JogoRequestDto> violation = violations.iterator().next();

        // Garante que o campo da violação seja o de dataLancamento
        assertThat(violation.getPropertyPath().toString()).isEqualTo("dataLancamento");

        // Garante que o texto de erro seja exatamente o definido
        assertThat(violation.getMessage()).isEqualTo("A data não pode ser no futuro.");
    }

    /*
        Teste para garantir que a data de lançamento
        não esteja vazia.
    */
    @Test
    public void quandoDataDeLancamentoENulaDeveHaverViolacaoDeNotNull() {
        var dto = new JogoRequestDto(
                "Jogo Inválido", "Descrição OK", null,
                null, // Data nula
                ClassificacaoIndicativa.LIVRE,
                List.of(Genero.AVENTURA),
                List.of(Plataforma.PC)
        );

        Set<ConstraintViolation<JogoRequestDto>> violations = validator.validate(dto);

        assertThat(violations).hasSize(1);
        ConstraintViolation<JogoRequestDto> violation = violations.iterator().next();

        assertThat(violation.getMessage()).isEqualTo("A data de lançamento é obrigatória");
    }
}


============================================================
CAMINHO: src\test\java\br\com\lunix\dto\UniqueEmailValidatorTest.java
============================================================
package br.com.lunix.dto;

import br.com.lunix.annotation.engine.UniqueEmailValidator;
import br.com.lunix.model.entities.Usuario;
import br.com.lunix.repository.UsuarioRepository;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.context.TestPropertySource;

import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.when;

/*
    Classe com testes para garantir que a anotação
    de email único esteja funcionando.
*/
@ExtendWith(MockitoExtension.class)
public class UniqueEmailValidatorTest {

    // Repositório mockado
    @Mock
    private UsuarioRepository repository;

    @InjectMocks
    private UniqueEmailValidator validator;

    /*
        Teste que garante que se o email não existir no banco
        ele permita o cadastro
    */
    @Test
    public void quandoEmailNaoExisteDeveSerValido() {
        String email = "novo@email.com";
        when(repository.findByEmail(email)).thenReturn(Optional.empty());

        boolean isValid = validator.isValid(email, null);

        assertThat(isValid).isTrue();
    }

    /*
        Teste que garante que quando o email já for
        pertencente a um usuário não permita o cadastro.
    */
    @Test
    public void quandoEmailJaExisteDeveSerInvalido() {
        String email = "existente@email.com";
        when(repository.findByEmail(email)).thenReturn(Optional.of(new Usuario()));

        boolean isValid = validator.isValid(email, null);

        assertThat(isValid).isFalse();
    }

}


============================================================
CAMINHO: src\test\java\br\com\lunix\live\ItadApiLiveTest.java
============================================================
package br.com.lunix.live;

import br.com.lunix.model.entities.PrecoPlataforma;
import br.com.lunix.services.itad.ItadApiService;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

@SpringBootTest
@Disabled("Este teste faz chamadas de rede reais e deve ser executado manualmente.")
public class ItadApiLiveTest {

    @Autowired
    private ItadApiService itadApiService;

    @Test
    public void deveConectarNaApiRealDoItadEBuscarPrecos() {
        // Cenário (Arrange)
        // Escolhemos um jogo popular que certamente terá preços em múltiplas lojas
        String termoBusca = "Hollow Knight: Silksong";

        // Ação (Act)
        List<PrecoPlataforma> resultado = itadApiService.buscarPrecosParaJogo(termoBusca);

        // Verificação (Assert)
        assertThat(resultado).isNotNull().isNotEmpty(); // A verificação principal é que a lista não esteja vazia

        // --- RELATÓRIO DE VOO (IMPRIMINDO TODOS OS RESULTADOS) ---
        System.out.println("========================================================");
        System.out.println("        RELATÓRIO DE PREÇOS - TESTE AO VIVO (ITAD)      ");
        System.out.println("========================================================");
        System.out.printf("Encontradas %d ofertas para '%s':\n\n", resultado.size(), termoBusca);

        for (PrecoPlataforma preco : resultado) {
            System.out.println("  Loja     : " + preco.getNomeLoja());
            System.out.println("  Preço    : " + preco.getPrecoAtual());
            System.out.println("  Base     : " + preco.getPrecoBase());
            System.out.println("  Desconto : " + preco.getDescontoPercentual() + "%");
            System.out.println("  --------------------");
        }
        System.out.println("========================================================");

        // Podemos manter uma verificação simples no primeiro item para garantir a estrutura
        PrecoPlataforma primeiroPreco = resultado.get(0);
        assertThat(primeiroPreco.getNomeLoja()).isNotBlank();
    }
}


============================================================
CAMINHO: src\test\java\br\com\lunix\live\RawgApiLiveTest.java
============================================================
package br.com.lunix.live;

import br.com.lunix.dto.rawg.RawgRecords.RawgGameDto;
import br.com.lunix.services.rawg.RawgApiService;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.TestPropertySource;

import java.util.List;
import java.util.stream.Collectors;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * ATENÇÃO: Este é um "Smoke Test" de integração REAL para a API RAWG.io.
 * Ele valida o novo fluxo de dados e exibe um relatório detalhado.
 * - Requer uma conexão com a internet.
 * - Requer uma chave de API válida no seu arquivo application.properties.
 * - Está desabilitado por padrão (@Disabled). Execute-o manualmente pela IDE.
 */
@SpringBootTest
@Disabled("Este teste faz uma chamada de rede real e deve ser executado manualmente.")
@TestPropertySource(properties = {
        "mongock.enabled=false"
})
public class RawgApiLiveTest {

    @Autowired
    private RawgApiService rawgApiService;

    @Test
    public void deveConectarNaApiRealDaRawgEBuscarDadosCompletos() {

        String termoBusca = "Hollow Knight: Silksong";
        int limite = 1;

        List<RawgGameDto> resultado = rawgApiService.buscarJogos(termoBusca, limite);

        assertThat(resultado).isNotNull().isNotEmpty();

        RawgGameDto jogo = resultado.get(0);

        assertThat(jogo.name()).containsIgnoringCase(termoBusca);
        assertThat(jogo.backgroundImage()).isNotNull().startsWith("https://");

        System.out.println("========================================================");
        System.out.println("          RELATÓRIO DE DADOS RAWG - TESTE AO VIVO       ");
        System.out.println("========================================================");
        System.out.printf("Dados encontrados para a busca '%s':\n\n", termoBusca);

        System.out.println("  Título               : " + jogo.name());
        System.out.println("  Slug                 : " + jogo.slug());
        System.out.println("  ID                   : " + jogo.id());
        System.out.println("  Data de Lançamento   : " + (jogo.released() != null ? jogo.released().format(java.time.format.DateTimeFormatter.ofPattern("dd/MM/yyyy")) : "N/A"));
        System.out.println("  URL da Capa          : " + jogo.backgroundImage());
        System.out.println("  Descrição            : " + (jogo.description() != null ? jogo.description().substring(0, Math.min(jogo.description().length(), 200)) + "..." : "N/A"));
        String classificacao = jogo.esrbRating() != null ? jogo.esrbRating().name() : "N/A";
        System.out.println("  Classificação ESRB   : " + classificacao);

        // Gêneros
        String generos = jogo.genres() != null ? jogo.genres().stream().map(g -> g.name()).collect(Collectors.joining(", ")) : "N/A";
        System.out.println("  Gêneros              : " + generos);

        // Desenvolvedores
        String desenvolvedores = jogo.developers() != null ? jogo.developers().stream().map(d -> d.name()).collect(Collectors.joining(", ")) : "N/A";
        System.out.println("  Desenvolvedores      : " + desenvolvedores);

        // Plataformas
        String plataformas = jogo.platforms() != null ? jogo.platforms().stream().map(p -> p.platform().name()).collect(Collectors.joining(", ")) : "N/A";
        System.out.println("  Plataformas          : " + plataformas);

        System.out.println("========================================================");
    }
}


============================================================
CAMINHO: src\test\java\br\com\lunix\mapper\ItadMapperTest.java
============================================================
package br.com.lunix.mapper;

import br.com.lunix.dto.itad.ItadRecords.*;
import br.com.lunix.model.entities.PrecoPlataforma;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class ItadMapperTest {

    private final ItadMapper mapper = new ItadMapper();

    @Test
    public void deveConverterDtoParaPrecoPlataformaComSucesso() {
        // Cenário (Arrange) - ATUALIZADO para a nova estrutura de DTO
        var shopDto = new ItadShopDto(1, "Steam");
        var priceDetails = new ItadPriceDetailsDto(9.99, "BRL"); // Novo DTO
        var regularDetails = new ItadPriceDetailsDto(19.99, "BRL"); // Novo DTO
        var dealDto = new ItadDealDto(shopDto, priceDetails, regularDetails, 50, "url/steam", null);

        // Ação (Act)
        PrecoPlataforma resultado = mapper.toPrecoPlataforma(dealDto);

        // Verificação (Assert)
        assertThat(resultado).isNotNull();
        assertThat(resultado.getNomeLoja()).isEqualTo("Steam");
        assertThat(resultado.getPrecoAtual()).isEqualTo(9.99);
        assertThat(resultado.getPrecoBase()).isEqualTo(19.99);
    }

    @Test
    public void deveRetornarNuloQuandoDtoForNulo() {
        assertThat(mapper.toPrecoPlataforma(null)).isNull();
    }
}

============================================================
CAMINHO: src\test\java\br\com\lunix\mapper\RawgMapperTest.java
============================================================
package br.com.lunix.mapper;

import br.com.lunix.dto.jogos.JogoMapeadoDto;
import br.com.lunix.dto.rawg.RawgRecords.*;
import br.com.lunix.model.entities.Jogo;
import br.com.lunix.model.enums.ClassificacaoIndicativa;
import br.com.lunix.model.enums.Genero;
import br.com.lunix.model.enums.Plataforma;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.time.LocalDate;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

public class RawgMapperTest {

    private RawgMapper mapper;

    @BeforeEach
    public void setup() {
        mapper = new RawgMapper();
    }

    @Test
    public void deveMapearRawgGameDtoParaJogoMapeadoComSucesso() {
        // Cenário (Arrange) - Criamos um DTO rico com todos os campos que esperamos
        var esrbDto = new RawgEsrbRatingDto(2, "Everyone 10+", "everyone-10-plus");
        var devDto = new RawgDeveloperDto(1, "Team Cherry", "team-cherry");
        var genreDto = new RawgGenreDto(1, "Adventure", "adventure");
        var platformDto = new RawgPlatformEntryDto(new RawgPlatformDto(4, "PC", "pc"));
        var rawgGameDto = new RawgGameDto(123, "hollow-knight", "Hollow Knight", LocalDate.of(2017, 2, 24),
                "url/capa.jpg", esrbDto, List.of(platformDto), List.of(genreDto), List.of(devDto), ""
        );

        // Ação (Act)
        JogoMapeadoDto resultado = mapper.toJogoMapeado(rawgGameDto);

        // Verificação (Assert)
        assertThat(resultado).isNotNull();

        // Verifica o nome do desenvolvedor
        assertThat(resultado.nomeDesenvolvedorPrincipal()).isEqualTo("Team Cherry");

        // Verifica os campos do jogo
        Jogo jogo = resultado.jogo();
        assertThat(jogo).isNotNull();
        assertThat(jogo.getTitulo()).isEqualTo("Hollow Knight");
        assertThat(jogo.getUrlCapa()).isEqualTo("url/capa.jpg");
        assertThat(jogo.getDataLancamento()).isEqualTo(LocalDate.of(2017, 2, 24));
        assertThat(jogo.getGeneros()).containsExactly(Genero.AVENTURA);
        assertThat(jogo.getPlataformas()).containsExactly(Plataforma.PC);
        assertThat(jogo.getClassificacao()).isEqualTo(ClassificacaoIndicativa.DEZ);
    }

    @Test
    public void deveLidarComListasNulasOuVaziasCorretamente() {
        // Cenário com listas nulas e vazias
        var rawgGameDto = new RawgGameDto(
                123, "slug", "Jogo Simples", null, null, null,
                null,
                List.of(),
                null,
                ""
        );

        // Ação
        JogoMapeadoDto resultado = mapper.toJogoMapeado(rawgGameDto);

        // Verificação
        assertThat(resultado).isNotNull();
        assertThat(resultado.jogo().getPlataformas()).isNotNull().isEmpty();
        assertThat(resultado.jogo().getGeneros()).isNotNull().isEmpty();
        assertThat(resultado.nomeDesenvolvedorPrincipal()).isNull();
    }

    @Test
    public void deveMapearSlugsDesconhecidosParaOutros() {
        var genreDto = new RawgGenreDto(99, "Music", "music");
        var platformDto = new RawgPlatformEntryDto(new RawgPlatformDto(99, "Atari 2600", "atari-2600"));
        var rawgGameDto = new RawgGameDto(
                456, "slug", "Jogo Legado", null, null, null,
                List.of(platformDto), List.of(genreDto), List.of(), null
        );

        // Ação
        JogoMapeadoDto resultado = mapper.toJogoMapeado(rawgGameDto);

        // Verificação
        assertThat(resultado).isNotNull();
        // Garante que nossa rede de segurança 'default' está funcionando
        assertThat(resultado.jogo().getGeneros()).containsExactly(Genero.OUTROS);
        assertThat(resultado.jogo().getPlataformas()).containsExactly(Plataforma.OUTROS);
    }

    @Test
    public void deveRetornarNuloQuandoDtoForNulo() {
        assertThat(mapper.toJogoMapeado(null)).isNull();
    }
}


============================================================
CAMINHO: src\test\java\br\com\lunix\model\enums\ClassificacaoIndicativaTest.java
============================================================
package br.com.lunix.model.enums;


import org.junit.jupiter.api.Test;
import org.springframework.test.context.TestPropertySource;

import static org.assertj.core.api.Assertions.assertThat;

/*
    Classe de teste para garantir que os valores
    definidos nos parâmetros do ENUM esteja realmente válidos
*/
@TestPropertySource(properties = "mongock.enabled=false")
public class ClassificacaoIndicativaTest {

    @Test
    public void deveRetornarAtributosCorretosParaClassificacaoLivre() {
        ClassificacaoIndicativa classificacao = ClassificacaoIndicativa.LIVRE;

        assertThat(classificacao.getSelo()).isEqualTo("L");
        assertThat(classificacao.getDescricao()).isEqualTo("Livre para todos os públicos");
        assertThat(classificacao.getCorHex()).isEqualTo("#008641");
    }

    @Test
    public void deveRetornarAtributosCorretosParaClassificacaoDez() {
        ClassificacaoIndicativa classificacao = ClassificacaoIndicativa.DEZ;

        assertThat(classificacao.getSelo()).isEqualTo("10");
        assertThat(classificacao.getDescricao()).isEqualTo("Não recomendado para menores de 10 anos");
        assertThat(classificacao.getCorHex()).isEqualTo("#00A5E3");
    }

    @Test
    public void deveRetornarAtributosCorretosParaClassificacaoDoze() {
        ClassificacaoIndicativa classificacao = ClassificacaoIndicativa.DOZE;

        assertThat(classificacao.getSelo()).isEqualTo("12");
        assertThat(classificacao.getDescricao()).isEqualTo("Não recomendado para menores de 12 anos");
        assertThat(classificacao.getCorHex()).isEqualTo("#F8A503");
    }

    @Test
    public void deveRetornarAtributosCorretosParaClassificacaoCatorze() {
        ClassificacaoIndicativa classificacao = ClassificacaoIndicativa.CATORZE;

        assertThat(classificacao.getSelo()).isEqualTo("14");
        assertThat(classificacao.getDescricao()).isEqualTo("Não recomendado para menores de 14 anos");
        assertThat(classificacao.getCorHex()).isEqualTo("#E87A1E");
    }

    @Test
    public void deveRetornarAtributosCorretosParaClassificacaoDezesseis() {
        ClassificacaoIndicativa classificacao = ClassificacaoIndicativa.DEZESSEIS;

        assertThat(classificacao.getSelo()).isEqualTo("16");
        assertThat(classificacao.getDescricao()).isEqualTo("Não recomendado para menores de 16 anos");
        assertThat(classificacao.getCorHex()).isEqualTo("#C42127");
    }

    @Test
    public void deveRetornarAtributosCorretosParaClassificacaoDezoito() {
        ClassificacaoIndicativa classificacao = ClassificacaoIndicativa.DEZOITO;

        assertThat(classificacao.getSelo()).isEqualTo("18");
        assertThat(classificacao.getDescricao()).isEqualTo("Não recomendado para menores de 18 anos");
        assertThat(classificacao.getCorHex()).isEqualTo("#231F20");
    }

    @Test
    public void enumDeveConterTodasAsSeisClassificacoes() {
        assertThat(ClassificacaoIndicativa.values()).hasSize(6);
    }





}


============================================================
CAMINHO: src\test\java\br\com\lunix\services\ItadApiServiceTest.java
============================================================
package br.com.lunix.services;

import br.com.lunix.mapper.ItadMapper;
import br.com.lunix.model.entities.PrecoPlataforma;
import br.com.lunix.services.itad.ItadApiService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.client.RestClientTest;
import org.springframework.context.annotation.Import;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.web.client.MockRestServiceServer;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.client.match.MockRestRequestMatchers.*;
import static org.springframework.test.web.client.response.MockRestResponseCreators.withSuccess;

@RestClientTest(ItadApiService.class)
@Import(ItadMapper.class)
@TestPropertySource(properties = {
        "itad.api.baseurl=https://api.isthereanydeal.com",
        "itad.api.key=TEST_ITAD_KEY",
        "mongock.enabled=false"
})
public class ItadApiServiceTest {

    @Autowired
    private ItadApiService itadApiService;

    @Autowired
    private MockRestServiceServer mockServer;

    @Autowired
    private ObjectMapper objectMapper;

    @BeforeEach
    public void setup() {
        mockServer.reset();
    }

    @Test
    public void deveBuscarPrecosComSucessoSeguindoNovoFluxoDaApi() throws Exception {
        // --- CENÁRIO (ARRANGE) ---
        String termoBusca = "Hades";
        String gameId = "018d937f-33f0-7200-80fc-87f769196c84";

        // ... (Mock da primeira chamada para /games/lookup/v1 permanece o mesmo) ...
        String lookupUrl = UriComponentsBuilder.fromUriString("https://api.isthereanydeal.com")
                .path("/games/lookup/v1")
                .queryParam("key", "TEST_ITAD_KEY").queryParam("title", termoBusca)
                .build().toUri().toString();
        String lookupResponse = """
                { "found": true, "game": { "id": "%s", "slug": "hades", "title": "Hades" } }
                """.formatted(gameId);
        mockServer.expect(requestTo(lookupUrl)).andRespond(withSuccess(lookupResponse, MediaType.APPLICATION_JSON));


        // Preparar a SEGUNDA chamada (POST para /games/prices/v3)
        String pricesUrl = UriComponentsBuilder.fromUriString("https://api.isthereanydeal.com")
                .path("/games/prices/v3")
                .queryParam("key", "TEST_ITAD_KEY").queryParam("country", "BR")
                .build().toUri().toString();

        List<String> expectedRequestBody = List.of(gameId);

        String pricesResponse = """
                [
                    {
                        "id": "%s",
                        "deals": [
                            {
                                "shop": {"id": 61, "name": "Steam"},
                                "price": {"amount": 47.49, "currency": "BRL"},
                                "regular": {"amount": 94.99, "currency": "BRL"},
                                "cut": 50,
                                "url": "url/steam",
                                "drm": [{"id": 61, "name": "Steam"}]
                            }
                        ]
                    }
                ]
                """.formatted(gameId);

        mockServer.expect(requestTo(pricesUrl))
                .andExpect(method(HttpMethod.POST))
                .andExpect(content().json(objectMapper.writeValueAsString(expectedRequestBody)))
                .andRespond(withSuccess(pricesResponse, MediaType.APPLICATION_JSON));

        // --- AÇÃO (ACT) ---
        List<PrecoPlataforma> resultado = itadApiService.buscarPrecosParaJogo(termoBusca);

        // --- VERIFICAÇÃO (ASSERT) ---
        mockServer.verify();

        assertThat(resultado).hasSize(1);
        PrecoPlataforma precoSteam = resultado.get(0);
        assertThat(precoSteam.getNomeLoja()).isEqualTo("Steam");
        assertThat(precoSteam.getPrecoAtual()).isEqualTo(47.49);
    }
}

============================================================
CAMINHO: src\test\java\br\com\lunix\services\RawgApiServiceTest.java
============================================================
package br.com.lunix.services;

import br.com.lunix.dto.rawg.RawgRecords.RawgGameDto;
import br.com.lunix.services.rawg.RawgApiService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.client.RestClientTest;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.test.context.TestPropertySource;
import org.springframework.test.web.client.MockRestServiceServer;
import org.springframework.web.util.UriComponentsBuilder;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.springframework.test.web.client.match.MockRestRequestMatchers.method;
import static org.springframework.test.web.client.match.MockRestRequestMatchers.requestTo;
import static org.springframework.test.web.client.response.MockRestResponseCreators.withSuccess;

/*
    Classe de testes para garantir que a service
    do RAWG consiga puxar os dados corretamente
    da API.
*/
@RestClientTest(RawgApiService.class)
@TestPropertySource(properties = {
        "rawg.api.baseurl=https://api.rawg.io",
        "rawg.api.key=TEST_API_KEY",
        "mongock.enabled=false"
})
class RawgApiServiceTest {

    @Autowired
    private RawgApiService rawgApiService;

    @Autowired
    private MockRestServiceServer mockServer;

    @BeforeEach
    void setup() {
        mockServer.reset();
    }

    /*
        Teste para garantir que ele vá buscar jogos utilizando
        o título com sucesso.
    */
    @Test
    public void deveBuscarJogosERetornarListaDeDTOsComSucesso() throws Exception {
        // Cenário (Arrange)
        String termoBusca = "hollow knight";
        int limite = 1;

        // 1. Construímos a URL EXATA que esperamos que nosso serviço chame.
        String expectedUrl = UriComponentsBuilder.fromUriString("https://api.rawg.io")
                .path("/api/games")
                .queryParam("key", "TEST_API_KEY")
                .queryParam("search", termoBusca)
                .queryParam("page_size", limite)
                .toUriString();

        // 2. Criamos o corpo da resposta JSON que nosso servidor FALSO irá devolver.
        String jsonResponse = """
                {
                    "results": [
                        {
                            "id": 12345,
                            "slug": "hollow-knight",
                            "name": "Hollow Knight",
                            "released": "2017-02-24",
                            "background_image": "https://example.com/hollow_knight.jpg",
                            "esrb_rating": { "id": 2, "name": "Everyone 10+", "slug": "everyone-10-plus" },
                            "platforms": [
                                { "platform": { "id": 4, "name": "PC", "slug": "pc" } }
                            ],
                            "genres": [{"id": 51, "name": "Indie", "slug": "indie"}],
                            "developers": [{"id": 987, "name": "Team Cherry", "slug": "team-cherry"}]
                        }
                    ]
                }
                """;

        mockServer.expect(requestTo(expectedUrl))
                .andExpect(method(HttpMethod.GET))
                .andRespond(withSuccess(jsonResponse, MediaType.APPLICATION_JSON));

        List<RawgGameDto> resultado = rawgApiService.buscarJogos("hollow knight", 1);

        mockServer.verify();
        assertThat(resultado).isNotNull().hasSize(1);
        RawgGameDto jogoRetornado = resultado.get(0);
        assertThat(jogoRetornado.name()).isEqualTo("Hollow Knight");
        assertThat(jogoRetornado.esrbRating()).isNotNull();
        assertThat(jogoRetornado.esrbRating().slug()).isEqualTo("everyone-10-plus");
    }
}
